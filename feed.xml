<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Corey Trujillo</title>
    <description>My Research</description>
    <link>/~ctrujillo/</link>
    <atom:link href="/~ctrujillo/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 25 Feb 2019 10:29:59 -0700</pubDate>
    <lastBuildDate>Wed, 16 Jan 2019 10:29:59 -0700</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
    
    <item>
      <title>OpenCL</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Assignment 10 (credit: 60, bonus)&quot; /&gt;
  &lt;title&gt;OpenCL&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;OpenCL&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Assignment 10 (credit: 60, bonus)&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;Due: 12/12&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;introduction&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In today’s lab session we will learn about OpenCL. OpenCL (Open Computing Language) is the open, royalty-free standard for cross-platform, parallel programming that execute across heterogeneous platforms consisting of central processing units (CPUs), graphics processing units (GPUs), digital signal processors (DSPs), field-programmable gate arrays (FPGAs) and other processors or hardware accelerators. The OpenCL does not have its own separate language, instead OpenCL standard defines a set of data types, data structures, and functions that augment C/C++.&lt;/p&gt;
&lt;p&gt;To facilitate portability between implementations for various host devices, programs in the OpenCL language are intended to be compiled at run-time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;For a quick summary of OpenCL components refer to &lt;a href=&quot;https://www.khronos.org/files/OpenCLPP12-reference-card.pdf&quot;&gt;OpenCL Reference Card&lt;/a&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;opencl-components&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;OpenCL components&lt;/h1&gt;
&lt;p&gt;Before we start coding using OpenCL, we need to understand the OpenCL Components and its architecture.&lt;/p&gt;
&lt;p&gt;An implementation of the OpenCL standard consists of a library that implements the API for C/C++, and an OpenCL C compiler for the targeted devices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;C Host API:&lt;/strong&gt; C API used to control the devices. (e.g., memory transfer, kernel compilation).
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;OpenCL C:&lt;/strong&gt; Used on the device (kernel language).
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/10-opencl_architecture.jpg&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;OpenCL architecture mainly consists of&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Host application&lt;/strong&gt;: Host is a regular C/C++ application running on the user’s development system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;: Kernel is a specially coded function that is intended to be executed by one or more OpenCL-compliant devices. Kernels are sent to their intended device or devices by host applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context&lt;/strong&gt;: Context is a container for using host application and manages their connected devices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Command Queue&lt;/strong&gt;: Command queue is the mechanism through which the host tells devices what to do, and when a kernel is enqueued, the device will execute the corresponding function.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt;: Program is a collection of kernels and other functions. To create a kernel, the host selects a function from program and then it associates the kernel with argument data and dispatches it to command queue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Devices&lt;/strong&gt;: The collection of OpenCL devices to be used by the host, such as CPU, GPU, DSP, FPGA, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory Objects&lt;/strong&gt;: A set of memory objects visible to the host and the OpenCL devices. Memory objects contain values that can be operated on by instances of a kernel&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Platforms&lt;/strong&gt;: The host plus a collection of devices managed by the OpenCL framework that allow an application to share resources and execute kernels on devices in the platform. The Platform API discover the devices available to you.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For further detailed information on OpenCL Architecture and Models, check &lt;a href=&quot;https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#page=22&quot;&gt;OpenCL Specification&lt;/a&gt;.&lt;/p&gt;
&lt;section id=&quot;opencl-memory-hierarchy&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;OpenCL Memory hierarchy&lt;/h2&gt;
&lt;p&gt;OpenCL defines a four-level memory hierarchy for the compute device:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;Global:&lt;/strong&gt; memory shared by all processing elements (&lt;code&gt;__global&lt;/code&gt;)
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;Read-only:&lt;/strong&gt; writable by the host CPU but not the compute devices (&lt;code&gt;__constant&lt;/code&gt;)
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;local:&lt;/strong&gt; shared by a group of processing elements (&lt;code&gt;__local&lt;/code&gt;)
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;private:&lt;/strong&gt; per-element private memory (e.g., registers; &lt;code&gt;__private&lt;/code&gt;)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, not every device needs to implement each level of this hierarchy in hardware. &lt;em&gt;Consistency between the various levels in the hierarchy is relaxed in the OpenCL standard, and only enforced by explicit synchronization constructs.&lt;/em&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;opencl-application-development&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;OpenCL application development&lt;/h1&gt;
&lt;p&gt;As we outline the application development framework in OpenCL, inspect the vector addition code in today’s lab folder and identify relevant parts.&lt;/p&gt;
&lt;section id=&quot;preparing-opencl-device-data-structures&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Preparing OpenCL device data structures&lt;/h2&gt;
&lt;section id=&quot;host-application&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Host application&lt;/h3&gt;
&lt;p&gt;In developing an OpenCL project, the first step is to code the host application. This runs on a user’s computer (the host) and dispatches kernels to connected devices. The host application can be written in C/C++. Every host application requires five data structures: &lt;code&gt;cl_device_id&lt;/code&gt;, &lt;code&gt;cl_kernel&lt;/code&gt;, &lt;code&gt;cl_program&lt;/code&gt;, &lt;code&gt;cl_command_queue&lt;/code&gt;, and &lt;code&gt;cl_context&lt;/code&gt;. OpenCL is completely contained in a single header. The APIs are written in C, and there is a C++ wrapper. We will be using the C APIs for our lab.&lt;/p&gt;
&lt;p&gt;OpenCL program starts with OpenCL header, exact path depends which OS you are using.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;pp&quot;&gt;#ifdef __APPLE__&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;pp&quot;&gt;#include &lt;/span&gt;&lt;span class=&quot;im&quot;&gt;&amp;quot;OpenCL/opencl.h&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;pp&quot;&gt;#else&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;    &lt;span class=&quot;pp&quot;&gt;#include &lt;/span&gt;&lt;span class=&quot;im&quot;&gt;&amp;quot;CL/cl.h&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;pp&quot;&gt;#endif&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;querying-platforms-and-devices&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Querying platforms and devices&lt;/h3&gt;
&lt;p&gt;Next, we need to find out which platforms are available&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;cl_int clGetPlatformIDs(cl_uint num_entries,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;                        cl_platform_id *platforms,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;                        cl_uint *num_platforms)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;num_entries&lt;/code&gt; is the number of &lt;code&gt;cl_platform_id&lt;/code&gt; entries that can be added to &lt;code&gt;platforms&lt;/code&gt;. If &lt;code&gt;platforms&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;num_entries&lt;/code&gt; must be greater than zero. Upon return, &lt;code&gt;platforms&lt;/code&gt; is a list of OpenCL platforms found and &lt;code&gt;num_platforms&lt;/code&gt; is the number of OpenCL platforms available. If either &lt;code&gt;platforms&lt;/code&gt; or &lt;code&gt;num_platforms&lt;/code&gt; argument is &lt;code&gt;NULL&lt;/code&gt;, that argument is ignored.&lt;/p&gt;
&lt;p&gt;Now, we can obtain a list of devices available on a platform&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;cl_int clGetDeviceIDs(cl_platform_id platform,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;cl_device_type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;device_type&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;                      cl_uint num_entries,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;                      cl_device_id *devices,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-5&quot; data-line-number=&quot;5&quot;&gt;                      cl_uint *num_devices)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;platform&lt;/code&gt; refers to the platform ID returned by &lt;code&gt;clGetPlatformIDs&lt;/code&gt;. &lt;code&gt;device_type&lt;/code&gt; is a bitfield that identifies the type of OpenCL device such as &lt;code&gt;CL_DEVICE_TYPE_CPU&lt;/code&gt;, &lt;code&gt;CL_DEVICE_TYPE_GPU&lt;/code&gt;, &lt;code&gt;CL_DEVICE_TYPE_ALL&lt;/code&gt;, etc. &lt;code&gt;num_entries&lt;/code&gt; is the number of &lt;code&gt;cl_device_id&lt;/code&gt; entries that can be added to &lt;code&gt;devices&lt;/code&gt;. &lt;code&gt;devices&lt;/code&gt; is returned as a list of OpenCL devices found and &lt;code&gt;num_devices&lt;/code&gt; is the number of OpenCL devices available that match &lt;code&gt;device_type&lt;/code&gt;. If either of &lt;code&gt;devices&lt;/code&gt; or &lt;code&gt;num_devices&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, that argument is ignored.&lt;/p&gt;
&lt;p&gt;For example, one can query one GPU by&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-1&quot; data-line-number=&quot;1&quot;&gt;clGetPlatformIDs(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;platform, NULL);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-2&quot; data-line-number=&quot;2&quot;&gt;clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;device, NULL);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;creating-opencl-context&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Creating OpenCL context&lt;/h3&gt;
&lt;p&gt;Next, the application creates a context containing device list—i.e., the device structure queried earlier. Contexts are used by the OpenCL runtime for managing objects such as command-queues, memory, program and kernel objects and for executing kernels on one or more devices specified in the context.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;co&quot;&gt;//typedef void (CL_CALLBACK *cl_callback_t)(const char *errinfo, const void *private_info, size_t cb, void *user_data),&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-2&quot; data-line-number=&quot;2&quot;&gt;cl_context clCreateContext(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_context_properties *properties,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-3&quot; data-line-number=&quot;3&quot;&gt;                           cl_uint num_devices,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-4&quot; data-line-number=&quot;4&quot;&gt;                           &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_device_id *devices,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-5&quot; data-line-number=&quot;5&quot;&gt;                           &lt;span class=&quot;dt&quot;&gt;cl_callback_t&lt;/span&gt; pfn_notify,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-6&quot; data-line-number=&quot;6&quot;&gt;                           &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *user_data,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-7&quot; data-line-number=&quot;7&quot;&gt;                           cl_int *errcode_ret)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Important arguments in declaration above are &lt;code&gt;num_devices&lt;/code&gt; that tells about number of devices in &lt;code&gt;devices&lt;/code&gt; list and the &lt;code&gt;devices&lt;/code&gt; which is the list of device IDs. Devices in same shared context can share the data.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;creating-command-queue&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Creating command queue&lt;/h3&gt;
&lt;p&gt;After creating context with the devices, we need to create command queue to allow us to talk to the device or devices. We need to have at least single command queue for devices in the system. To create command queue, we call &lt;code&gt;clCreateCommandQueue&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;cl_command_queue clCreateCommandQueue(cl_context context,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-2&quot; data-line-number=&quot;2&quot;&gt;                                      cl_device_id device,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-3&quot; data-line-number=&quot;3&quot;&gt;                                      &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_command_queue_properties properties,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-4&quot; data-line-number=&quot;4&quot;&gt;                                      cl_int *errcode_ret)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;device&lt;/code&gt; must be a device associated with the &lt;code&gt;context&lt;/code&gt; created before. &lt;code&gt;properties&lt;/code&gt; is a bitfield and specifies a list of properties for the command queue, such as &lt;code&gt;CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE&lt;/code&gt;, &lt;code&gt;CL_QUEUE_PROFILING_ENABLE&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-1&quot; data-line-number=&quot;1&quot;&gt;queue_dev1 = clCreateCommandQueue(context, devices[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &amp;amp;err);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-2&quot; data-line-number=&quot;2&quot;&gt;queue_dev2 = clCreateCommandQueue(context, devices[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &amp;amp;err);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;creating-and-building-program-object&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Creating and building program object&lt;/h3&gt;
&lt;p&gt;Next in application, we create a program object from the source code in the kernel file, typically named with a &lt;code&gt;.cl&lt;/code&gt; extension. Specifically, the code reads the file’s content into a char array called &lt;code&gt;program_buffer&lt;/code&gt;, and then calls &lt;code&gt;clCreateProgramWithSource&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-1&quot; data-line-number=&quot;1&quot;&gt;cl_program clCreateProgramWithSource(cl_context context,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-2&quot; data-line-number=&quot;2&quot;&gt;                                     cl_uint count,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-3&quot; data-line-number=&quot;3&quot;&gt;                                     &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; **strings,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-4&quot; data-line-number=&quot;4&quot;&gt;                                     &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; *lengths,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-5&quot; data-line-number=&quot;5&quot;&gt;                                     cl_int *errcode_ret)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;strings&lt;/code&gt; is an array of &lt;code&gt;count&lt;/code&gt; pointers to optionally null-terminated character strings that make up the source code. &lt;code&gt;lengths&lt;/code&gt; argument is an array with the number of chars in each string (i.e, the string length).&lt;/p&gt;
&lt;p&gt;Once the program is created, its source code must be compiled for the devices in the context. The function that accomplishes this is &lt;code&gt;clBuildProgram&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;co&quot;&gt;//typedef void (CL_CALLBACK *cl_callback_t)(cl_program program, void *user_data)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-2&quot; data-line-number=&quot;2&quot;&gt;cl_int clBuildProgram(cl_program program,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-3&quot; data-line-number=&quot;3&quot;&gt;                      cl_uint num_devices,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-4&quot; data-line-number=&quot;4&quot;&gt;                      &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_device_id *device_list,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-5&quot; data-line-number=&quot;5&quot;&gt;                      &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *options,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-6&quot; data-line-number=&quot;6&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;cl_callback_t&lt;/span&gt; pfn_notify,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-7&quot; data-line-number=&quot;7&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *user_data)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;device_list&lt;/code&gt; is a pointer to a list of devices associated with the program. If &lt;code&gt;device_list&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the program executable is built for all devices associated with the program for which a source or binary has been loaded. &lt;code&gt;pfn_notify&lt;/code&gt; is a function pointer to a notification routine. The notification routine is a callback function that an application can register and which will be called when the program executable has been built (successfully or unsuccessfully). &lt;code&gt;options&lt;/code&gt; is a string of characters of OpenCL specific options for building the program.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;creating-kernel-object&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Creating kernel object&lt;/h3&gt;
&lt;p&gt;A kernel is a function declared in a program. A kernel is identified by the &lt;code&gt;__kernel&lt;/code&gt; qualifier in a program. kernels are written in the &lt;strong&gt;OpenCL C&lt;/strong&gt; which is a subset of C and provides a rich set of built-in functions for scalar and vector operations.&lt;/p&gt;
&lt;p&gt;After a &lt;code&gt;cl_program&lt;/code&gt; has been compiled, kernels can be created from its functions:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-1&quot; data-line-number=&quot;1&quot;&gt;cl_kernel clCreateKernel(cl_program program,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-2&quot; data-line-number=&quot;2&quot;&gt;                         &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *kernel_name,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-3&quot; data-line-number=&quot;3&quot;&gt;                         cl_int *errcode_ret)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;program&lt;/code&gt; is a program object with a successfully built executable. &lt;code&gt;kernel_name&lt;/code&gt; is a function name in the program declared with the &lt;code&gt;__kernel&lt;/code&gt; qualifier. Similarly, the function &lt;code&gt;clCreateKernelsInProgram&lt;/code&gt; creates kernel objects for all kernel functions in &lt;code&gt;program&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To execute a kernel on an OpenCL device, the kernel arguments must be set. The function &lt;code&gt;clSetKernelArg&lt;/code&gt; is used to set the argument value for a specific argument of a kernel&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb11&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-1&quot; data-line-number=&quot;1&quot;&gt;cl_int clSetKernelArg(cl_kernel kernel,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-2&quot; data-line-number=&quot;2&quot;&gt;                      cl_uint arg_index,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-3&quot; data-line-number=&quot;3&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; arg_size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-4&quot; data-line-number=&quot;4&quot;&gt;                      &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg_value)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;arg_index&lt;/code&gt; is the argument index.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;creating-memory-buffer&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Creating memory buffer&lt;/h3&gt;
&lt;p&gt;A buffer object stores a one-dimensional collection of elements. Elements of a buffer object can be a scalar data type (such as an int, float), vector data type, or a user-defined structure. Since a device can have different memory space, we need to move data from host to device and back. GPUs for instance have on-board memory which is completely separate from the host memory.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb12&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-1&quot; data-line-number=&quot;1&quot;&gt;cl_mem clCreateBuffer(cl_context context,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-2&quot; data-line-number=&quot;2&quot;&gt;                      cl_mem_flags flags,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-3&quot; data-line-number=&quot;3&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-4&quot; data-line-number=&quot;4&quot;&gt;                      &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *host_ptr,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-5&quot; data-line-number=&quot;5&quot;&gt;                      cl_int *errcode_ret)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt; is the size in bytes of the buffer memory object to be allocated. &lt;code&gt;host_ptr&lt;/code&gt; is a pointer to the buffer data in the host address space that may already be allocated by the application. &lt;code&gt;flags&lt;/code&gt; is a bit-field that to specify allocation and usage information for the buffer object, such as &lt;code&gt;CL_MEM_READ_WRITE&lt;/code&gt;, &lt;code&gt;CL_MEM_READ_ONLY&lt;/code&gt;, &lt;code&gt;CL_MEM_WRITE_ONLY&lt;/code&gt;, &lt;code&gt;CL_MEM_HOST_WRITE_ONLY&lt;/code&gt;, etc. If flag is &lt;code&gt;0&lt;/code&gt;, then default (&lt;code&gt;CL_MEM_READ_WRITE&lt;/code&gt;) is used.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;reading-writing-and-copying-buffer-objects&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Reading, writing, and copying buffer objects&lt;/h3&gt;
&lt;p&gt;The following function is used to read from a buffer object to host memory&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb13&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-1&quot; data-line-number=&quot;1&quot;&gt;cl_int clEnqueueReadBuffer(cl_command_queue command_queue,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-2&quot; data-line-number=&quot;2&quot;&gt;                           cl_mem buffer,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-3&quot; data-line-number=&quot;3&quot;&gt;                           cl_bool blocking_read,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-4&quot; data-line-number=&quot;4&quot;&gt;                           &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; offset,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-5&quot; data-line-number=&quot;5&quot;&gt;                           &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-6&quot; data-line-number=&quot;6&quot;&gt;                           &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *ptr,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-7&quot; data-line-number=&quot;7&quot;&gt;                           cl_uint num_events_in_wait_list,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-8&quot; data-line-number=&quot;8&quot;&gt;                           &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_event *event_wait_list,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-9&quot; data-line-number=&quot;9&quot;&gt;                           cl_event *event)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;command_queue&lt;/code&gt; refers to the queue in which the read/write command will be queued. &lt;code&gt;buffer&lt;/code&gt; refers to a valid buffer object. &lt;code&gt;blocking_read&lt;/code&gt; and &lt;code&gt;blocking_write&lt;/code&gt; indicate if the read and write operations are blocking or non-blocking. If &lt;code&gt;blocking_read&lt;/code&gt; is &lt;code&gt;CL_FALSE&lt;/code&gt;, then the read command is non-blocking and &lt;code&gt;clEnqueueReadBuffer&lt;/code&gt; queues a non-blocking read command and returns. The event argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that &lt;code&gt;ptr&lt;/code&gt; points to can be used by the application. &lt;code&gt;blocking_write&lt;/code&gt; flag follows the same pattern. &lt;code&gt;offset&lt;/code&gt; is the offset in bytes in the buffer object to read from or write to. &lt;code&gt;size&lt;/code&gt; is the size in bytes of data being read or written.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clEnqueueWriteBuffer&lt;/code&gt; has similar signature and is used to write to a buffer object from host memory.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;executing-code-on-the-device&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Executing code on the device&lt;/h2&gt;
&lt;p&gt;At this point, the application has created all the runtime data structures (device, kernel, program, command queue, and context) needed by an OpenCL host application. Now, it can deploys the kernel to devices.&lt;/p&gt;
&lt;section id=&quot;executing-kernel-objects&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Executing Kernel Objects&lt;/h3&gt;
&lt;p&gt;Parallel work is submitted to devices by launching kernels. To deploy the kernel to a device one uses &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;. Not only does this function deploy kernels to devices, it also identifies how many work-items should be generated to execute the kernel (&lt;code&gt;global_size&lt;/code&gt;) and the number of work-items in each work-group (&lt;code&gt;local_size&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;emphbox&quot;&gt;
&lt;p&gt;The OpenCL programming model is SPMD (single program, multiple data). The fine-grained object that runs a code on the device is called a &lt;em&gt;work item&lt;/em&gt;. Each work item has a unique index. A monolithic array of work items is typically divided into work groups. Within a work group, work items cooperate via shared memory, atomic operations and barrier synchronization. However, work items in different work groups cannot cooperate.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb14&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-1&quot; data-line-number=&quot;1&quot;&gt;cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-2&quot; data-line-number=&quot;2&quot;&gt;                              cl_kernel kernel,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-3&quot; data-line-number=&quot;3&quot;&gt;                              cl_uint work_dim,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-4&quot; data-line-number=&quot;4&quot;&gt;                              &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; *global_work_offset,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-5&quot; data-line-number=&quot;5&quot;&gt;                              &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; *global_work_size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-6&quot; data-line-number=&quot;6&quot;&gt;                              &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; *local_work_size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-7&quot; data-line-number=&quot;7&quot;&gt;                              cl_uint num_events_in_wait_list,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-8&quot; data-line-number=&quot;8&quot;&gt;                              &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; cl_event *event_wait_list,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-9&quot; data-line-number=&quot;9&quot;&gt;                              cl_event *event)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, to execute a &lt;code&gt;kernel&lt;/code&gt; by eight work-items divided into two work-groups of four work-items each, one writes&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb15&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-1&quot; data-line-number=&quot;1&quot;&gt;global_size = &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-2&quot; data-line-number=&quot;2&quot;&gt;local_size = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-3&quot; data-line-number=&quot;3&quot;&gt;clEnqueueNDRangeKernel(queue, kernel, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, NULL, &amp;amp;global_size,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-4&quot; data-line-number=&quot;4&quot;&gt;                       &amp;amp;local_size, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;, &lt;code&gt;work_dim&lt;/code&gt; is the number of dimensions used to specify the global work-items. &lt;code&gt;global_work_offset&lt;/code&gt;, &lt;code&gt;global_work_size&lt;/code&gt;, and &lt;code&gt;local_work_size&lt;/code&gt; are all arrays of size &lt;code&gt;work_dim&lt;/code&gt;. &lt;code&gt;global_work_offset&lt;/code&gt; describes the offset used to calculate the global ID of a work-item. &lt;code&gt;global_work_size&lt;/code&gt; describes the number of global work-items in each &lt;code&gt;work_dim&lt;/code&gt; dimensions that will execute the kernel function. &lt;code&gt;local_work_size&lt;/code&gt; is an array describing the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the kernel specified by &lt;code&gt;kernel&lt;/code&gt;. If &lt;code&gt;local_work_size&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the OpenCL implementation will determine how to be break the global work-items into appropriate work-group instances.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;built-in-functions&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Built-in functions&lt;/h3&gt;
&lt;p&gt;There are few built-in work-item functions that can be used to query the number of dimensions, the global and local work sizes specified to &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;, and the global and local identifiers of each work-item when this kernel is being executed on a device.&lt;/p&gt;
&lt;div class=&quot;emphbox&quot;&gt;
&lt;p&gt;During execution, using these functions, a work item can decide which piece of data to operate on.&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;uint get_work_dim()&lt;/code&gt; returns the number of dimensions in use. This is the value given to the &lt;code&gt;work_dim&lt;/code&gt; argument specified in &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;size_t get_global_size(uint dimindx)&lt;/code&gt; returns the number of global work-items specified for dimension identified by &lt;code&gt;dimindx&lt;/code&gt;. This value is given by the &lt;code&gt;global_work_size&lt;/code&gt; argument to &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;. Valid values of &lt;code&gt;dimindx&lt;/code&gt; are 0 to &lt;code&gt;get_work_dim()–1&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;size_t get_global_id(uint dimindx)&lt;/code&gt; returns the unique global work-item ID value for dimension identified by &lt;code&gt;dimindx&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;size_t get_local_size(uint dimindx)&lt;/code&gt; returns the number of local work-items specified for dimension identified by &lt;code&gt;dimindx&lt;/code&gt;. This value is given by the &lt;code&gt;local_work_size&lt;/code&gt; argument to &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;size_t get_local_id(uint dimindx)&lt;/code&gt; returns the unique local work-item ID value for dimension identified by &lt;code&gt;dimindx&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;size_t get_group_id(uint dimindx)&lt;/code&gt;: returns the work-group ID.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;address-spaces&quot; class=&quot;level3&quot;&gt;
&lt;h3&gt;Address spaces&lt;/h3&gt;
&lt;p&gt;The address space qualifier may be used in variable declarations to specify the region of memory that is used to allocate the object. The C syntax for type qualifiers is extended in OpenCL to include an address space name as a valid type qualifier. If the type of an object is qualified by an address space name, the object is allocated in the specified address name; otherwise, the object is allocated in the generic address space (&lt;code&gt;__private&lt;/code&gt;). There is no address space for function return values. Using an address space qualifier in a function return type declaration will generate a compilation error.&lt;/p&gt;
&lt;p&gt;OpenCL implements the following disjoint address spaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;__global&lt;/code&gt; is used to refer to memory objects (buffer or image objects) allocated from the global memory pool.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;__local&lt;/code&gt; is used to describe variables that need to be allocated in local memory and are shared by all work-items of a work-group.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;__constant&lt;/code&gt; is used to describe variables allocated in global memory and which are accessed inside kernels as read-only variables. These read-only variables can be accessed by all (global) work-items of the kernel during its execution.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;__private&lt;/code&gt; is the default qualifier for variables inside a kernel function not declared with an explicit address space qualifier, all variables inside non-kernel functions, and all function arguments are in private address space.
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;task&quot;&gt;
&lt;h3&gt;Task 1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Describe whether and how the OpenCL kernel iterates over items in the input vectors when executing &lt;code&gt;vector_add&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mandelbrot_set&quot;&gt;Mandelbrot set&lt;/a&gt; is defined as the set of complex numbers &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; for which the quadratic map&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation}\label{eq:set} z_{n+1} = z_{n}^2 + c, \quad z_0 = 0,\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;is bounded. Complex number &lt;span class=&quot;math inline&quot;&gt;\(z=x+iy\)&lt;/span&gt; could be identified with a point in &lt;span class=&quot;math inline&quot;&gt;\(\mathbb{R}^2\)&lt;/span&gt; as &lt;span class=&quot;math inline&quot;&gt;\(p=(x,y)\)&lt;/span&gt;. Our objective is to write a program that generates the bitmap of the Mandelbrot set.&lt;/p&gt;
&lt;p&gt;To decide whether a pixel is inside the set, you can apply Eq. &lt;span class=&quot;math inline&quot;&gt;\(\eqref{eq:set}\)&lt;/span&gt;, for some number of iterations &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; and stop if &lt;span class=&quot;math inline&quot;&gt;\(|z_{k}| &amp;gt; 2\)&lt;/span&gt; for any &lt;span class=&quot;math inline&quot;&gt;\(k\le m\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Write an OpenCL function that generates the Mandelbrot set. This function needs to take care of all the required setup for OpenCL.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb16&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; xmin, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; xmax, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; ymin, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; ymax, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-2&quot; data-line-number=&quot;2&quot;&gt;     &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; max_iter, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *mandelbrot);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;The input domain is rectangle defined by [&lt;code&gt;xmin&lt;/code&gt;,&lt;code&gt;xmax&lt;/code&gt;]&lt;span class=&quot;math inline&quot;&gt;\(\times\)&lt;/span&gt;[&lt;code&gt;ymin&lt;/code&gt;,&lt;code&gt;ymax&lt;/code&gt;].&lt;/li&gt;
&lt;li&gt;There are &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; pixels in the &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; direction and &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; pixels in the &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; direction.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The output &lt;code&gt;mandelbrot&lt;/code&gt; is an array of size &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; corresponding to each pixel. It holds the number if iteration it takes the series to diverge or &lt;code&gt;max_iter&lt;/code&gt;. Points with &lt;code&gt;max_iter&lt;/code&gt; are assumed to be inside the set.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Experiment with the &lt;code&gt;local_size&lt;/code&gt; argument to &lt;code&gt;clEnqueueNDRangeKernel&lt;/code&gt; and report any effect you observe.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Report timing for &lt;span class=&quot;math inline&quot;&gt;\(n=256, 512, 1024, 2048\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Wed, 28 Nov 2018 00:00:00 -0700</pubDate>
      <link>/~rahimian/articles/18/hpc18-14-lab-opencl.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-14-lab-opencl.html</guid>
      
      
      <category>assignment</category>
      
    </item>
    
    <item>
      <title>Iterative solvers</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Assignment 9 (credit: 50)&quot; /&gt;
  &lt;title&gt;Iterative solvers&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Iterative solvers&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Assignment 9 (credit: 50)&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;Due: 11/16&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;iterative-solvers&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Iterative solvers&lt;/h1&gt;
&lt;p&gt;In a previous assignment, you worked on many components required for iteratively solving the Poisson’s equation. In this assignment, you will build an iterative solvers.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;jacobi-solver&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Jacobi solver&lt;/h1&gt;
&lt;p&gt;In assignment 6, you wrote a function to do poisson matvec (here we refer to that as &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;) and compute the residual. Write a Jacobi iterative solver for the Poisson’s equation based on the matvec you developed. Instead of changing the matvec and tailoring it to Jacobi, you can subtract and add the diagonal and write&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
L u &amp;amp;= f, \\
(L-D+D) u &amp;amp;= f, \\
D u^+ &amp;amp;= f - (L - D) u,\\
u^+ &amp;amp;= D^{-1}[f - Lu + D u],\\
u^+ &amp;amp;= D^{-1}[r + D u],
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(D=\mathrm{diag}(L)\)&lt;/span&gt; and I used the “&lt;span class=&quot;math inline&quot;&gt;\(+\)&lt;/span&gt;” superscript to denote the next update to &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;. Equations (4,5) imply that you can compute the matvec &lt;span class=&quot;math inline&quot;&gt;\(Lu\)&lt;/span&gt; followed by the residual &lt;span class=&quot;math inline&quot;&gt;\(r=f-Lu\)&lt;/span&gt;. If the residual satisfies the conditions outlined below terminate, otherwise generate a new update and iterate. This way, you are only computing the matvec once per iteration.&lt;/p&gt;
&lt;p&gt;Terminate at iteration &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; if &lt;span class=&quot;math inline&quot;&gt;\(\|r\| &amp;lt; \epsilon_r \|r_0\| + \epsilon_a\)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;\(k &amp;gt; k_{\max}\)&lt;/span&gt;. Here &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; is the residual, &lt;span class=&quot;math inline&quot;&gt;\(r_0\)&lt;/span&gt; is the initial residual, &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_r\)&lt;/span&gt; is the relative tolerance, and &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_a\)&lt;/span&gt; is the absolute tolerance.&lt;/p&gt;
&lt;p&gt;Write a Jacobi solver with the following signature:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @comm MPI communicator (to compute residual)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @mv the matvec&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @diag diagonal component of the matvec&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @rhs the right hand side&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @u0 initial guess&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @eps_r relative tolerance&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @eps_a absolute tolerance&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @m check residual every m iterations&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-10&quot; data-line-number=&quot;10&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @k_max the maximum number of iteration&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-11&quot; data-line-number=&quot;11&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @u_final return value&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-12&quot; data-line-number=&quot;12&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @k the number of iteration taken&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-13&quot; data-line-number=&quot;13&quot;&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-14&quot; data-line-number=&quot;14&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; jacobi_solver(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; MPI_Comm &amp;amp;comm, &lt;span class=&quot;dt&quot;&gt;matvec_t&lt;/span&gt; &amp;amp;mv, &lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-15&quot; data-line-number=&quot;15&quot;&gt;                 &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;&amp;gt; &amp;amp;diag, &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;&amp;gt; &amp;amp;rhs,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-16&quot; data-line-number=&quot;16&quot;&gt;                 &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;&amp;gt; &amp;amp;u0, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; eps_r, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; eps_a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k_max,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-17&quot; data-line-number=&quot;17&quot;&gt;                 &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;&amp;gt; &amp;amp;u_final, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &amp;amp;k);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When calling &lt;code&gt;jacobi_solver&lt;/code&gt; for the Poisson’s equation, you need to make a wrapper for &lt;code&gt;possion_matvec&lt;/code&gt; that has the same signature as &lt;code&gt;matvec_t&lt;/code&gt;. As we did in assignment 7, the easiest way to do that is&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;matvec_t&lt;/span&gt; mv = &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;bind(poisson_matvec, &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;ref(grid_comm), n, &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;ref(a),&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;                        &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;placeholders&lt;span class=&quot;bu&quot;&gt;::&lt;/span&gt;_1, &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;placeholders&lt;span class=&quot;bu&quot;&gt;::&lt;/span&gt;_2);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;task&quot;&gt;
&lt;h3&gt;Task 1&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Submit your implementation for this function in &lt;code&gt;w09/jacobi.cc&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;With &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_r = 10^{-5}\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_a = 10^{-12}\)&lt;/span&gt; report the number of iterations for &lt;span class=&quot;math inline&quot;&gt;\(n=\{256,512,758,1024\}\)&lt;/span&gt;. Use &lt;span class=&quot;math inline&quot;&gt;\(p=64\)&lt;/span&gt; and&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f = \sin(2\pi x)\sin(12\pi y)\sin(8\pi z). \]&lt;/span&gt;&lt;/p&gt;
&lt;strong&gt;&lt;em&gt;Note that for &lt;span class=&quot;math inline&quot;&gt;\(n=1024\)&lt;/span&gt; you are solving a system with more than one billion unknowns&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Sun, 04 Nov 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-10-lab-iterative.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-10-lab-iterative.html</guid>
      
      
      <category>assignment</category>
      
    </item>
    
    <item>
      <title>Graph algorithms</title>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot;&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Abtin Rahimian&quot;&gt;
  &lt;meta name=&quot;dcterms.date&quot; content=&quot;2017-10-28&quot;&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;title&gt;Graph algorithms&lt;/title&gt;
  &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/reveal.css&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/theme/white.css&quot; id=&quot;theme&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot;/&gt;
  &lt;!-- Printing and PDF exports --&gt;
  &lt;script&gt;
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'assets/js/reveal.js/css/print/pdf.css' : 'assets/js/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  &lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
  &lt;script src=&quot;assets/js/reveal.js/lib/js/html5shiv.js&quot;&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;reveal&quot;&gt;
    &lt;div class=&quot;slides&quot;&gt;

&lt;section&gt;
  &lt;h1 class=&quot;title&quot;&gt;Graph algorithms&lt;/h1&gt;
  &lt;p class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/p&gt;
  &lt;p class=&quot;author&quot;&gt;Abtin Rahimian&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;October 28, 2017&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;&lt;section id=&quot;introduction&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Introduction&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;logistics&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Logistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Class calendar
&lt;ul&gt;
&lt;li&gt;December 11 &amp;amp; 13 project presentations.&lt;/li&gt;
&lt;li&gt;No new assignment this week (one more before the break, last one after the break bonus).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reading
&lt;ul&gt;
&lt;li&gt;Roofline model paper for next week.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Resource
&lt;ul&gt;
&lt;li&gt;Gramma et al., chapter 10,&lt;/li&gt;
&lt;li&gt;Blelloch paper,&lt;/li&gt;
&lt;li&gt;JáJá, chapter 5.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;case-studies&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Case studies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dense graph algorithm
&lt;ul&gt;
&lt;li&gt;Minimum spanning tree&lt;/li&gt;
&lt;li&gt;Single-source shortest path&lt;/li&gt;
&lt;li&gt;Connected component&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sparse graph algorithms
&lt;ul&gt;
&lt;li&gt;Breadth first search&lt;/li&gt;
&lt;li&gt;Graph contraction&lt;/li&gt;
&lt;li&gt;Maximal independent set&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graphs and matrices&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graph partitioning&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;definitions&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt; is a graph (directed/undirected) with &lt;span class=&quot;math inline&quot;&gt;\(|V|=n\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(|E|=m\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Represented by adjacency matrix, list, array
&lt;ul&gt;
&lt;li&gt;Matrix is symmetric for undirected,&lt;/li&gt;
&lt;li&gt;Weights as entry (0 diagonal, &lt;span class=&quot;math inline&quot;&gt;\(\infty\)&lt;/span&gt; for no edge),&lt;/li&gt;
&lt;li&gt;Adjacency array is more practical for parallel algorithm.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Adjacency array is the Compressed Sparse Row (CSR) storage of adjacency matrix.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;minimum-spanning-tree-mst&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Minimum spanning tree (MST)&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;sequential-mst&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Sequential MST&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;A sub-graph of &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt; containing all vertices &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; and a subset of &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;It is a tree (forest)&lt;/li&gt;
&lt;li&gt;Has minimum edge weights for a weighed undirected graph&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sequential MST?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Prim’s algorithm
&lt;ul&gt;
&lt;li&gt;Greedy&lt;/li&gt;
&lt;li&gt;Start from a random vertex&lt;/li&gt;
&lt;li&gt;Iteratively expand the tree by picking the edge with &lt;strong&gt;&lt;em&gt;minimum cost&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Relies on the &lt;em&gt;cut property&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-mst.png&quot; class=&quot;center&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;cut-property&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Cut property&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A cut is any partition of the vertices into two groups, &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Suppose edges &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; (green edges) are part of a minimum spanning tree of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;.
&lt;ul&gt;
&lt;li&gt;Pick any subset of nodes &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; for which &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; does not cross between &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt; be the lightest edge across this partition&lt;/li&gt;
&lt;li&gt;Then &lt;span class=&quot;math inline&quot;&gt;\(X \cup \{e\}\)&lt;/span&gt; is part of some MST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;It is always safe to add the lightest edge across any cut (that is, between a vertex in &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and one in &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;), provided &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; has no edges across the cut.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-cut.png&quot; class=&quot;center&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;prims-algorithm&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Prim’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Maintain a distance array &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; from all vertices to constructed &lt;span class=&quot;math inline&quot;&gt;\(MST\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Upon termination &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; holds the aggregate cost of the MST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-prim1.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt; &lt;img data-src=&quot;assets/dedicated-hpc18/img/09-prim2.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;prims-algorithm-cont.&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Prim’s algorithm (cont.)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Maintain a distance array &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; from all vertices to constructed &lt;span class=&quot;math inline&quot;&gt;\(MST\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Upon termination &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; holds the aggregate cost of the MST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-prim3.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt; &lt;img data-src=&quot;assets/dedicated-hpc18/img/09-prim4.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-mst&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel MST&lt;/h2&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Partition the adjacency matrix column-wise and update the distance matrix,&lt;/li&gt;
&lt;li&gt;Partition the distance matrix accordingly,&lt;/li&gt;
&lt;li&gt;All-to-all reduction for the global max (to find the edge with minimum cost),&lt;/li&gt;
&lt;li&gt;Cost?&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ T_p = \frac{n^2}{p} + n (t_s + t_w ) \log p \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Work optimal&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;single-source-shortest-path&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Single-source shortest path&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;dijastras-algorithm&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Dijastra’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Very similar to Prim’s algorithm
&lt;ul&gt;
&lt;li&gt;Instead of distance to the spanning tree, keep track of distance to the source&lt;/li&gt;
&lt;li&gt;Iteratively mark nearest vertex as visited, update neighbors’ distance&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;connected-component&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Connected component&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;sequential-connected-component&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Sequential connected component&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Partition &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; into sub-graphs &lt;span class=&quot;math inline&quot;&gt;\(G_j=(V_j,E_j)\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(V = V_1\cup \dots \cup V_k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(u,v \in V_j\)&lt;/span&gt; if and only if there is a path from &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Output is labels for each vertex&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Iterative depth/breadth first search
&lt;ul&gt;
&lt;li&gt;Using list representation&lt;/li&gt;
&lt;li&gt;Start searching from a vertex and label&lt;/li&gt;
&lt;li&gt;Increment label, pick a new vertex from unlabeled list, and repeat&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-connected-component&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel connected component&lt;/h2&gt;
&lt;div class=&quot;slide-pillars fragment&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Distribute the adjacency matrix row-wise among processors
&lt;ul&gt;
&lt;li&gt;All processors have all vertices&lt;/li&gt;
&lt;li&gt;Each processor has a sub-graph &lt;span class=&quot;math inline&quot;&gt;\(G_i=(V,E_i)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Each processor computes the DFS/BFS, the connected components, or the spanning forest&lt;/li&gt;
&lt;li&gt;Merge?&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-cc.png&quot; class=&quot;center&quot; width=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;merging-spanning-forests&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Merging spanning forests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Given two spanning forests &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Each has at most &lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt; edges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For each edge &lt;span class=&quot;math inline&quot;&gt;\((u,v)\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Find labels of &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Continue if labels are the same&lt;/li&gt;
&lt;li&gt;If labels are different, union trees in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; marked by labels&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Operations
&lt;ul&gt;
&lt;li&gt;Cost of find &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Number of finds is at most &lt;span class=&quot;math inline&quot;&gt;\(2(n-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Number of unions at most &lt;span class=&quot;math inline&quot;&gt;\((n-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Cost &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; (with proper choice of data structure)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-complexity&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Computing spanning forest locally&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{n^2}{p} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How many merge?&lt;/li&gt;
&lt;li&gt;Communication pattern?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; merges, we can do it like reduction,&lt;/li&gt;
&lt;li&gt;Merge can be done in &lt;span class=&quot;math inline&quot;&gt;\(\log p\)&lt;/span&gt; time,&lt;/li&gt;
&lt;li&gt;Message is the spanning forest.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T_p = \frac{n^2}{p} + (t_s + t_w n) \log p\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;sparse-graph-algorithms&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Sparse graph algorithms&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;sparse-graph-considerations&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Sparse graph considerations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Faster algorithm by leveraging sparseness&lt;/li&gt;
&lt;li&gt;Load imbalance&lt;/li&gt;
&lt;li&gt;Extra communication&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-bfs-on-pram&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel BFS (on PRAM)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Similar to sequential BFS
&lt;ul&gt;
&lt;li&gt;Keep a frontier of vertices to be visited next&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Visit the whole frontier concurrently&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;How to construct new frontier?&lt;/li&gt;
&lt;li&gt;what is the cost?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Cost
&lt;ul&gt;
&lt;li&gt;Each vertex is visited once, each edge is visited at most twice: &lt;span class=&quot;math inline&quot;&gt;\(O(n+m).\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Depth: graph diameter (maximum distance between any two vertex).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-bfs-on-pram-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel BFS (on PRAM)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pick a random vertex as source&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Store the BFS &lt;code&gt;tree&lt;/code&gt; in an array, each vertex holds its parent’s index (source holds self)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set source as &lt;code&gt;frontier&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;For all vertices in the &lt;code&gt;frontier&lt;/code&gt;, set that to be the parent of its unvisited neighbors (&lt;strong&gt;&lt;em&gt;concurrent write&lt;/em&gt;&lt;/strong&gt; in &lt;code&gt;tree&lt;/code&gt;)
&lt;ul&gt;
&lt;li&gt;One random vertex wins and becomes parent,&lt;/li&gt;
&lt;li&gt;Parent adds child to the frontier list,
&lt;ul&gt;
&lt;li&gt;All candidate parents check, but one writes to frontier.&lt;/li&gt;
&lt;li&gt;Each vertex is added only once to the frontier list.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;graph-contraction&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Graph contraction&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;random-mate-graph-contraction&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Random mate graph contraction&lt;/h2&gt;
&lt;ol start=&quot;0&quot; type=&quot;1&quot;&gt;
&lt;li&gt;Keep the adjacency information in &lt;strong&gt;&lt;em&gt;edge list (explicitly maintain &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;For each vertex, flip a coin and randomly mark it as parent or child&lt;/li&gt;
&lt;li&gt;For each child vertex (&lt;span class=&quot;math inline&quot;&gt;\(\approx\)&lt;/span&gt; half of vertices), select a neighboring vertex marked as parent
&lt;ul&gt;
&lt;li&gt;Make that vertex the parent&lt;/li&gt;
&lt;li&gt;If a child has no &lt;em&gt;parent&lt;/em&gt; neighbor, mark it as orphan&lt;/li&gt;
&lt;li&gt;Each parent has zero or more children&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Contract each parent (update edge list)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Expected to remove &lt;span class=&quot;math inline&quot;&gt;\(1/4\)&lt;/span&gt; of remaining vertices. It is very unlikely to need more than &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt; contractions&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;rmgc-example&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;RMGC example&lt;/h2&gt;
&lt;div class=&quot;centering&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-rmgc1.png&quot; height=&quot;350&quot; /&gt; &lt;img data-src=&quot;assets/dedicated-hpc18/img/09-rmgc2.png&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-rmgc&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel RMGC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Assign random bit to each vertex&lt;/li&gt;
&lt;li&gt;Assign parent, &lt;span class=&quot;math inline&quot;&gt;\(\{(u,v)\in E\; |\; child[u]\; \&amp;amp;\&amp;amp;\; !child[v] \}\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;&lt;em&gt;concurrent write&lt;/em&gt;&lt;/strong&gt; (one arbitrary parent wins)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Contract (update edges, drop edges with the same label)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Each contraction
&lt;ul&gt;
&lt;li&gt;Work &lt;span class=&quot;math inline&quot;&gt;\(O(n+m)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Depth &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Work &lt;span class=&quot;math inline&quot;&gt;\((n+m)\log n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Depth &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-connected-component-revisited&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel connected component revisited&lt;/h2&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Recursively contract using parallel RMGC&lt;/li&gt;
&lt;li&gt;Expand and propagate label&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-spanning-tree&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel spanning tree&lt;/h2&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Keep track of the parent/child relationships when contracting in RMGC&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallel-mst-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallel MST&lt;/h2&gt;
&lt;div class=&quot;slide-pillars fragment&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Use the cut property
&lt;ul&gt;
&lt;li&gt;For &lt;span class=&quot;math inline&quot;&gt;\(S\subset V\)&lt;/span&gt;, the minimum edge connecting &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt; is in an MST&lt;/li&gt;
&lt;li&gt;The minimum incident to each vertex is in some MST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Algorithm:
&lt;ul&gt;
&lt;li&gt;Contract, pick as parent only if it is on the minimum edge (orphan otherwise)&lt;/li&gt;
&lt;li&gt;Keep track of edges similar to spanning tree&lt;/li&gt;
&lt;li&gt;Since we are using edge list, find the minimum edge efficiently is not trivial.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-par-mst.png&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;maximal-independent-set&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Maximal independent set&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;maximal-independent-set-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Maximal independent set&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Graph &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Set &lt;span class=&quot;math inline&quot;&gt;\(I \subset V\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;For &lt;span class=&quot;math inline&quot;&gt;\(u,v \in I, (u,v)\notin E\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Maximal&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sequential
&lt;ul&gt;
&lt;li&gt;Iteratively add a vertex to the list&lt;/li&gt;
&lt;li&gt;Remove its neighbors as candidate&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;lubys-algorithm&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Luby’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How to break symmetry?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Assign distinct &lt;strong&gt;&lt;em&gt;random numbers&lt;/em&gt;&lt;/strong&gt; to vertices
&lt;ul&gt;
&lt;li&gt;Add vertex to &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; if it has the least number among its neighbors&lt;/li&gt;
&lt;li&gt;Remove adjacent vertices (concurrent write)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In practice instead of distinct random numbers, pick a number in range, e.g., &lt;span class=&quot;math inline&quot;&gt;\([1,n^4]\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Low probability of collision&lt;/li&gt;
&lt;li&gt;Break symmetry by using vertex index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Converge after &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt; iterations&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;matrices-and-graphs&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Matrices and graphs&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;gaussian-elimination&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gaussian elimination&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interpret the matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; as an adjacency matrix (ignore value)
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(a_{ij} \ne 0\)&lt;/span&gt;, there is an edge between vertex &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Symmetric matrices correspond to undirected graphs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What operation does Gaussian elimination imply on the graph?&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;illustrative-example&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Illustrative example&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-ge.png&quot; class=&quot;center&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Gaussian elimination eliminates node &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; and connects all paths that go through &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; (all neighbors)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;illustrative-example-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Illustrative example&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;It is better to start elimination from leaves&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-ge-reorg.png&quot; class=&quot;center&quot; height=&quot;250&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if the matrix is not &lt;strong&gt;tree&lt;/strong&gt; structured?
&lt;ul&gt;
&lt;li&gt;At least cluster nodes&lt;/li&gt;
&lt;li&gt;Postpone interaction of cluster to the end&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;dissection-of-a-regular-grid&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Dissection of a regular grid&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-nested.png&quot; class=&quot;center&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;reordered-matrix-based-on-dissection&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Reordered matrix based on dissection&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
A &amp;amp;= LU\\
L &amp;amp;=\begin{bmatrix} I &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; I &amp;amp; 0 \\A_{31}A_{11}^{-1}&amp;amp; A_{32}A_{22}^{-1} &amp;amp; I \\\end{bmatrix}\\
U &amp;amp;=\begin{bmatrix} A_{11} &amp;amp; 0 &amp;amp; A_{13} \\ 0 &amp;amp; A_{22} &amp;amp; A_{23} \\0 &amp;amp; 0 &amp;amp; S_{33} \\\end{bmatrix}\\
S_{33} &amp;amp;= A_{33} - A_{31}A_{11}^{-1}A_{13} - A_{32}A_{22}^{-1}A_{23}
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-dissection.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;nested-dissection&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Nested dissection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Recursively reorder sub-blocks until they are small
&lt;ul&gt;
&lt;li&gt;Maintain the same &lt;strong&gt;&lt;em&gt;interior to boundary ratio&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Work on sub-domains in parallel&lt;/li&gt;
&lt;li&gt;combine results using the interface block&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interface matrix &lt;span class=&quot;math inline&quot;&gt;\(S_{33}\)&lt;/span&gt; is dense&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;For 2D, &lt;span class=&quot;math inline&quot;&gt;\(N=n\times n\)&lt;/span&gt; unknowns
&lt;ul&gt;
&lt;li&gt;Storage: &lt;span class=&quot;math inline&quot;&gt;\(M(n) = 4M(\frac{n}{2}) + \frac{3}{2}n^2, M(N) = O(N\log N)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Time: &lt;span class=&quot;math inline&quot;&gt;\(C(n) = 4C(\frac{n}{2}) + \frac{5}{4}n^3, C(N) = O(N^{3/2})\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For 3D, &lt;span class=&quot;math inline&quot;&gt;\(N=n\times n\times n\)&lt;/span&gt; unknowns
&lt;ul&gt;
&lt;li&gt;Memory (fill-ins) &lt;span class=&quot;math inline&quot;&gt;\(O(N^{4/3})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Cost &lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;graph-partitioning&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Graph Partitioning&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;graph-partitioning-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Graph partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Consider a weighted undirect graph &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E,W_v, W_e)\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_v\)&lt;/span&gt; is the set of vertex weights&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_e\)&lt;/span&gt; is the set of edge weights&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Interpretation
&lt;ul&gt;
&lt;li&gt;Nodes are tasks&lt;/li&gt;
&lt;li&gt;Node weights are task cost&lt;/li&gt;
&lt;li&gt;Edge are task dependencies/communication&lt;/li&gt;
&lt;li&gt;Edge weights are message size&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;graph-partitioning-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Graph partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Choose a partition &lt;span class=&quot;math inline&quot;&gt;\(V = V_1 \cup V_2 \dots \cup V_n\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;The sum of the node weights in each &lt;span class=&quot;math inline&quot;&gt;\(V_j\)&lt;/span&gt; is &lt;em&gt;almost equal&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The sum of all weights for edges crossing the cuts is minimized&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We will consider bisection (recursively apply for more partitions)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NP-complete problem: &lt;span class=&quot;math inline&quot;&gt;\({n \choose n/2} \approx 2^n\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;applications-of-graph-partitioning&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Applications of graph partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Load balancing&lt;/li&gt;
&lt;li&gt;Sparse matvec&lt;/li&gt;
&lt;li&gt;Solving PDEs (e.g., Poisson’s equation)&lt;/li&gt;
&lt;li&gt;Physical networks (VLSI layout in circuit design)&lt;/li&gt;
&lt;li&gt;Sparse Gaussian elimination&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;vertex-and-edge-separators&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Vertex and Edge separators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Edge separator:&lt;/strong&gt; A set of edges &lt;span class=&quot;math inline&quot;&gt;\(E_s\)&lt;/span&gt;, if removed from &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt; disconnects the graph to two components with approximately same size&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Vertex separator:&lt;/strong&gt; Set of vertices &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; that breaks the graph to two parts if removed&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;One can be generated from the other
&lt;ul&gt;
&lt;li&gt;Given &lt;span class=&quot;math inline&quot;&gt;\(E_s\)&lt;/span&gt; remove one end vertex of each edge&lt;/li&gt;
&lt;li&gt;Given &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; remove all incident edges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;graphs-with-coordinate-information&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Graphs with coordinate information&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;E.g., graphs from discretization of PDEs
&lt;ul&gt;
&lt;li&gt;Nodes are embedded in &lt;span class=&quot;math inline&quot;&gt;\(2D\)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;\(3D\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Nodes are connected to other &lt;strong&gt;&lt;em&gt;physically near&lt;/em&gt;&lt;/strong&gt; nodes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theorem:&lt;/strong&gt; A planar graph has a vertex separator &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(|V_s|\le \sqrt{8n}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;inertial-partitioning&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Inertial partitioning&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Objective is to find a bisecting hyperplane&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Each vertex has a coordinate &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}_i\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Find the center of mass in space&lt;/li&gt;
&lt;li&gt;Find the line &lt;span class=&quot;math inline&quot;&gt;\(I_0\)&lt;/span&gt; that minimizes the sum of squared-distance of points (total least squares fit)&lt;/li&gt;
&lt;li&gt;Find the median hyperplane orthogonal to &lt;span class=&quot;math inline&quot;&gt;\(I_0\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/09-inertial.png&quot; class=&quot;center fragment slide-pillar&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;coordinate-free-graphs&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Coordinate free graphs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What can we do for coordinate free graphs?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use BFS&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BFS property: There is no edge between a node and its indirect descendants&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start from a random vertex &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and partition by distance from &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;greedy-refinement&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Greedy refinement&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size
&lt;ul&gt;
&lt;li&gt;Exchange nodes that have most gain&lt;/li&gt;
&lt;li&gt;Stop when there is no positive gain&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;kernighan-lin-algorithm&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Consider an edge weighted graph &lt;span class=&quot;math inline&quot;&gt;\(W_v\equiv 1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size&lt;/li&gt;
&lt;li&gt;Cost of current partitioning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T = \sum_{p\in P, q\in Q} w(p,q) \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cost of a vertex:
&lt;ul&gt;
&lt;li&gt;External &lt;span class=&quot;math inline&quot;&gt;\(C_e(p) = \sum_{r\in Q} w(p,r)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Internal &lt;span class=&quot;math inline&quot;&gt;\(C_i(p) = \sum_{r\in P} w(p,r)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Moving vertex &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; from &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; changes &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;\(D(p) = C_i(p)-C_e(p)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Exchanging two vertices changes &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; by&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g(p,q) = D(p) + D(q) - 2w(p,q)\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;kernighan-lin-algorithm-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size&lt;/p&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Find a vertex pair that maximizes the gain &lt;span class=&quot;math inline&quot;&gt;\(g(p,q)\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Store the gain function as &lt;span class=&quot;math inline&quot;&gt;\(g_k\)&lt;/span&gt; (&lt;span class=&quot;math inline&quot;&gt;\(g_k\)&lt;/span&gt; could be negative)&lt;/p&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;Mark &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; for swap and lock them (do not consider them for any future exchanges)
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;Update &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; for all adjacent vertices (as if &lt;span class=&quot;math inline&quot;&gt;\(p,q\)&lt;/span&gt; were swapped)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Iterate until all vertices are locked&lt;/p&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Find the index &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; that has the maximum partial sum &lt;span class=&quot;math inline&quot;&gt;\(\sum_{k=1}^m g_k\)&lt;/span&gt; and only apply those swaps&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;kernighan-lin-algorithm-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cost
&lt;ul&gt;
&lt;li&gt;Each selection is &lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Each pass is &lt;span class=&quot;math inline&quot;&gt;\(O(n^3)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Converges to (local) minimum in a few sweeps&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;spectral-partitioning&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Another way to formulate the graph bisection problem&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Find binary labeling &lt;span class=&quot;math inline&quot;&gt;\(x_u=\pm 1\)&lt;/span&gt; for vertex &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; such that its an even partitioning&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{u\in V} x_u = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use the value of the label for bisection&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Edge cut cost&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f = \frac{1}{4} \sum_{(u,v)\in E} (x_u - x_v)^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;spectral-partitioning-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The incidence matrix &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; is an &lt;span class=&quot;math inline&quot;&gt;\(n\times m\)&lt;/span&gt; matrix with one row for each node and one column for each vertex&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ C_{u,e} = \begin{cases}1 &amp;amp; e=(u,v)\\-1 &amp;amp; e=(v,u)\\0 &amp;amp; \text{otherwise} \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;&lt;em&gt;Laplacian matrix&lt;/em&gt;&lt;/strong&gt; of the graph is an &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L_{u,v} = \begin{cases}d(u) &amp;amp; u=v\\-1 &amp;amp; (u,v)\in E\\0 &amp;amp; \text{otherwise} \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It turns out &lt;span class=&quot;math inline&quot;&gt;\(L = CC^T\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;spectral-partitioning-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The edge cut cost can be written&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f = \frac{1}{4} \| C^T x \|^2 = \frac{1}{4} x^T L x \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The relaxed problem is&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min x^T L x\qquad\text{subject to}\qquad x^T e = 0 \quad\text{and}\quad x^T x = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(e=(1,1,\dots,1)^T\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Equivalent to finding the second smallest eigenvalue of &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; and its corresponding eigenvector &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Partition based on the sign of &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expensive but high quality partition&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;large-graphs&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Large graphs&lt;/h2&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use a multilevel approach&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contract the graph until small (use maximal matching)&lt;/li&gt;
&lt;li&gt;Partition the coarsest level&lt;/li&gt;
&lt;li&gt;Expand and use the partitioning as initial guess for an iterative refinement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script src=&quot;assets/js/reveal.js/lib/js/head.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;assets/js/reveal.js/js/reveal.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Display the page number of the current slide
        slideNumber: 'c',
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Enables touch navigation on devices with touch input
        touch: true,
        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom
        // The &quot;normal&quot; size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 720,


      // Optional reveal.js plugins
      dependencies: [
          { src: 'assets/js/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'assets/js/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'assets/js/reveal.js/plugin/notes/notes.js', async: true }
      ]
      });
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 29 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-09-graph.sl.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-09-graph.sl.html</guid>
      
      
      <category>lecture</category>
      
    </item>
    
    <item>
      <title>Graph algorithms</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Abtin Rahimian&quot; /&gt;
  &lt;meta name=&quot;date&quot; content=&quot;2017-10-28&quot; /&gt;
  &lt;title&gt;Graph algorithms&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Graph algorithms&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Abtin Rahimian&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;October 28, 2017&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;introduction&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;section id=&quot;logistics&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Logistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Class calendar
&lt;ul&gt;
&lt;li&gt;
December 11 &amp;amp; 13 project presentations.
&lt;/li&gt;
&lt;li&gt;
No new assignment this week (one more before the break, last one after the break bonus).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Reading
&lt;ul&gt;
&lt;li&gt;
Roofline model paper for next week.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Resource
&lt;ul&gt;
&lt;li&gt;
Gramma et al., chapter 10,
&lt;/li&gt;
&lt;li&gt;
Blelloch paper,
&lt;/li&gt;
&lt;li&gt;
JáJá, chapter 5.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;case-studies&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Case studies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Dense graph algorithm
&lt;ul&gt;
&lt;li&gt;
Minimum spanning tree
&lt;/li&gt;
&lt;li&gt;
Single-source shortest path
&lt;/li&gt;
&lt;li&gt;
Connected component
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Sparse graph algorithms
&lt;ul&gt;
&lt;li&gt;
Breadth first search
&lt;/li&gt;
&lt;li&gt;
Graph contraction
&lt;/li&gt;
&lt;li&gt;
Maximal independent set
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphs and matrices&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graph partitioning&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;definitions&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt; is a graph (directed/undirected) with &lt;span class=&quot;math inline&quot;&gt;\(|V|=n\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(|E|=m\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Represented by adjacency matrix, list, array
&lt;ul&gt;
&lt;li&gt;
Matrix is symmetric for undirected,
&lt;/li&gt;
&lt;li&gt;
Weights as entry (0 diagonal, &lt;span class=&quot;math inline&quot;&gt;\(\infty\)&lt;/span&gt; for no edge),
&lt;/li&gt;
&lt;li&gt;
Adjacency array is more practical for parallel algorithm.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Adjacency array is the Compressed Sparse Row (CSR) storage of adjacency matrix.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;minimum-spanning-tree-mst&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Minimum spanning tree (MST)&lt;/h1&gt;
&lt;section id=&quot;sequential-mst&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Sequential MST&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
A sub-graph of &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt; containing all vertices &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; and a subset of &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;
It is a tree (forest)
&lt;/li&gt;
&lt;li&gt;
Has minimum edge weights for a weighed undirected graph
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Sequential MST?
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Prim’s algorithm
&lt;ul&gt;
&lt;li&gt;
Greedy
&lt;/li&gt;
&lt;li&gt;
Start from a random vertex
&lt;/li&gt;
&lt;li&gt;
Iteratively expand the tree by picking the edge with &lt;strong&gt;&lt;em&gt;minimum cost&lt;/em&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;
Relies on the &lt;em&gt;cut property&lt;/em&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-mst.png&quot; class=&quot;center&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;cut-property&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Cut property&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A cut is any partition of the vertices into two groups, &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Suppose edges &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; (green edges) are part of a minimum spanning tree of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;.
&lt;ul&gt;
&lt;li&gt;
Pick any subset of nodes &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; for which &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; does not cross between &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Let &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt; be the lightest edge across this partition
&lt;/li&gt;
&lt;li&gt;
Then &lt;span class=&quot;math inline&quot;&gt;\(X \cup \{e\}\)&lt;/span&gt; is part of some MST
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
It is always safe to add the lightest edge across any cut (that is, between a vertex in &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; and one in &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt;), provided &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; has no edges across the cut.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-cut.png&quot; class=&quot;center&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;prims-algorithm&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Prim’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Maintain a distance array &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; from all vertices to constructed &lt;span class=&quot;math inline&quot;&gt;\(MST\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Upon termination &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; holds the aggregate cost of the MST
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-prim1.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt; &lt;img src=&quot;assets/dedicated-hpc18/img/09-prim2.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Maintain a distance array &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; from all vertices to constructed &lt;span class=&quot;math inline&quot;&gt;\(MST\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Upon termination &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; holds the aggregate cost of the MST
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-prim3.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt; &lt;img src=&quot;assets/dedicated-hpc18/img/09-prim4.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-mst&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel MST&lt;/h2&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Partition the adjacency matrix column-wise and update the distance matrix,
&lt;/li&gt;
&lt;li&gt;
Partition the distance matrix accordingly,
&lt;/li&gt;
&lt;li&gt;
All-to-all reduction for the global max (to find the edge with minimum cost),
&lt;/li&gt;
&lt;li&gt;
Cost?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ T_p = \frac{n^2}{p} + n (t_s + t_w ) \log p \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Work optimal
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;single-source-shortest-path&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Single-source shortest path&lt;/h1&gt;
&lt;section id=&quot;dijastras-algorithm&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Dijastra’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Very similar to Prim’s algorithm
&lt;ul&gt;
&lt;li&gt;
Instead of distance to the spanning tree, keep track of distance to the source
&lt;/li&gt;
&lt;li&gt;
Iteratively mark nearest vertex as visited, update neighbors’ distance
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;connected-component&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Connected component&lt;/h1&gt;
&lt;section id=&quot;sequential-connected-component&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Sequential connected component&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Partition &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; into sub-graphs &lt;span class=&quot;math inline&quot;&gt;\(G_j=(V_j,E_j)\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(V = V_1\cup \dots \cup V_k\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(u,v \in V_j\)&lt;/span&gt; if and only if there is a path from &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Output is labels for each vertex&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Iterative depth/breadth first search
&lt;ul&gt;
&lt;li&gt;
Using list representation
&lt;/li&gt;
&lt;li&gt;
Start searching from a vertex and label
&lt;/li&gt;
&lt;li&gt;
Increment label, pick a new vertex from unlabeled list, and repeat
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-connected-component&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel connected component&lt;/h2&gt;
&lt;div class=&quot;slide-pillars fragment&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Distribute the adjacency matrix row-wise among processors
&lt;ul&gt;
&lt;li&gt;
All processors have all vertices
&lt;/li&gt;
&lt;li&gt;
Each processor has a sub-graph &lt;span class=&quot;math inline&quot;&gt;\(G_i=(V,E_i)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Each processor computes the DFS/BFS, the connected components, or the spanning forest
&lt;/li&gt;
&lt;li&gt;
Merge?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-cc.png&quot; class=&quot;center&quot; width=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;merging-spanning-forests&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Merging spanning forests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Given two spanning forests &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Each has at most &lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt; edges
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
For each edge &lt;span class=&quot;math inline&quot;&gt;\((u,v)\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Find labels of &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Continue if labels are the same
&lt;/li&gt;
&lt;li&gt;
If labels are different, union trees in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; marked by labels
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Operations
&lt;ul&gt;
&lt;li&gt;
Cost of find &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Number of finds is at most &lt;span class=&quot;math inline&quot;&gt;\(2(n-1)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Number of unions at most &lt;span class=&quot;math inline&quot;&gt;\((n-1)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Cost &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; (with proper choice of data structure)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-complexity&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Computing spanning forest locally
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{n^2}{p} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
How many merge?
&lt;/li&gt;
&lt;li&gt;
Communication pattern?
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; merges, we can do it like reduction,
&lt;/li&gt;
&lt;li&gt;
Merge can be done in &lt;span class=&quot;math inline&quot;&gt;\(\log p\)&lt;/span&gt; time,
&lt;/li&gt;
&lt;li&gt;
Message is the spanning forest.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T_p = \frac{n^2}{p} + (t_s + t_w n) \log p\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;sparse-graph-algorithms&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Sparse graph algorithms&lt;/h1&gt;
&lt;section id=&quot;sparse-graph-considerations&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Sparse graph considerations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Faster algorithm by leveraging sparseness
&lt;/li&gt;
&lt;li&gt;
Load imbalance
&lt;/li&gt;
&lt;li&gt;
Extra communication
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-bfs-on-pram&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel BFS (on PRAM)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Similar to sequential BFS
&lt;ul&gt;
&lt;li&gt;
Keep a frontier of vertices to be visited next
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;&lt;em&gt;Visit the whole frontier concurrently&lt;/em&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;
How to construct new frontier?
&lt;/li&gt;
&lt;li&gt;
what is the cost?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Cost
&lt;ul&gt;
&lt;li&gt;
Each vertex is visited once, each edge is visited at most twice: &lt;span class=&quot;math inline&quot;&gt;\(O(n+m).\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Depth: graph diameter (maximum distance between any two vertex).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-bfs-on-pram-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel BFS (on PRAM)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pick a random vertex as source&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Store the BFS &lt;code&gt;tree&lt;/code&gt; in an array, each vertex holds its parent’s index (source holds self)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set source as &lt;code&gt;frontier&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
For all vertices in the &lt;code&gt;frontier&lt;/code&gt;, set that to be the parent of its unvisited neighbors (&lt;strong&gt;&lt;em&gt;concurrent write&lt;/em&gt;&lt;/strong&gt; in &lt;code&gt;tree&lt;/code&gt;)
&lt;ul&gt;
&lt;li&gt;
One random vertex wins and becomes parent,
&lt;/li&gt;
&lt;li&gt;
Parent adds child to the frontier list,
&lt;ul&gt;
&lt;li&gt;
All candidate parents check, but one writes to frontier.
&lt;/li&gt;
&lt;li&gt;
Each vertex is added only once to the frontier list.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;graph-contraction&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Graph contraction&lt;/h1&gt;
&lt;section id=&quot;random-mate-graph-contraction&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Random mate graph contraction&lt;/h2&gt;
&lt;ol start=&quot;0&quot; type=&quot;1&quot;&gt;
&lt;li&gt;Keep the adjacency information in &lt;strong&gt;&lt;em&gt;edge list (explicitly maintain &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;For each vertex, flip a coin and randomly mark it as parent or child&lt;/li&gt;
&lt;li&gt;For each child vertex (&lt;span class=&quot;math inline&quot;&gt;\(\approx\)&lt;/span&gt; half of vertices), select a neighboring vertex marked as parent
&lt;ul&gt;
&lt;li&gt;
Make that vertex the parent
&lt;/li&gt;
&lt;li&gt;
If a child has no &lt;em&gt;parent&lt;/em&gt; neighbor, mark it as orphan
&lt;/li&gt;
&lt;li&gt;
Each parent has zero or more children
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Contract each parent (update edge list)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Expected to remove &lt;span class=&quot;math inline&quot;&gt;\(1/4\)&lt;/span&gt; of remaining vertices. It is very unlikely to need more than &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt; contractions&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;rmgc-example&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;RMGC example&lt;/h2&gt;
&lt;div class=&quot;centering&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-rmgc1.png&quot; height=&quot;350&quot; /&gt; &lt;img src=&quot;assets/dedicated-hpc18/img/09-rmgc2.png&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-rmgc&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel RMGC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Assign random bit to each vertex
&lt;/li&gt;
&lt;li&gt;
Assign parent, &lt;span class=&quot;math inline&quot;&gt;\(\{(u,v)\in E\; |\; child[u]\; \&amp;amp;\&amp;amp;\; !child[v] \}\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Use &lt;strong&gt;&lt;em&gt;concurrent write&lt;/em&gt;&lt;/strong&gt; (one arbitrary parent wins)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contract (update edges, drop edges with the same label)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Each contraction
&lt;ul&gt;
&lt;li&gt;
Work &lt;span class=&quot;math inline&quot;&gt;\(O(n+m)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Depth &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Work &lt;span class=&quot;math inline&quot;&gt;\((n+m)\log n\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Depth &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-connected-component-revisited&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel connected component revisited&lt;/h2&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Recursively contract using parallel RMGC
&lt;/li&gt;
&lt;li&gt;
Expand and propagate label
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-spanning-tree&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel spanning tree&lt;/h2&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Keep track of the parent/child relationships when contracting in RMGC
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallel-mst-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallel MST&lt;/h2&gt;
&lt;div class=&quot;slide-pillars fragment&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Use the cut property
&lt;ul&gt;
&lt;li&gt;
For &lt;span class=&quot;math inline&quot;&gt;\(S\subset V\)&lt;/span&gt;, the minimum edge connecting &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(V-S\)&lt;/span&gt; is in an MST
&lt;/li&gt;
&lt;li&gt;
The minimum incident to each vertex is in some MST
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Algorithm:
&lt;ul&gt;
&lt;li&gt;
Contract, pick as parent only if it is on the minimum edge (orphan otherwise)
&lt;/li&gt;
&lt;li&gt;
Keep track of edges similar to spanning tree
&lt;/li&gt;
&lt;li&gt;
Since we are using edge list, find the minimum edge efficiently is not trivial.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-par-mst.png&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;maximal-independent-set&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Maximal independent set&lt;/h1&gt;
&lt;section id=&quot;maximal-independent-set-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Maximal independent set&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Graph &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E)\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Set &lt;span class=&quot;math inline&quot;&gt;\(I \subset V\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
For &lt;span class=&quot;math inline&quot;&gt;\(u,v \in I, (u,v)\notin E\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Maximal
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Sequential
&lt;ul&gt;
&lt;li&gt;
Iteratively add a vertex to the list
&lt;/li&gt;
&lt;li&gt;
Remove its neighbors as candidate
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;lubys-algorithm&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Luby’s algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
How to break symmetry?
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Assign distinct &lt;strong&gt;&lt;em&gt;random numbers&lt;/em&gt;&lt;/strong&gt; to vertices
&lt;ul&gt;
&lt;li&gt;
Add vertex to &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; if it has the least number among its neighbors
&lt;/li&gt;
&lt;li&gt;
Remove adjacent vertices (concurrent write)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
In practice instead of distinct random numbers, pick a number in range, e.g., &lt;span class=&quot;math inline&quot;&gt;\([1,n^4]\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Low probability of collision
&lt;/li&gt;
&lt;li&gt;
Break symmetry by using vertex index
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Converge after &lt;span class=&quot;math inline&quot;&gt;\(O(\log n)\)&lt;/span&gt; iterations
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;matrices-and-graphs&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Matrices and graphs&lt;/h1&gt;
&lt;section id=&quot;gaussian-elimination&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Gaussian elimination&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Interpret the matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; as an adjacency matrix (ignore value)
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(a_{ij} \ne 0\)&lt;/span&gt;, there is an edge between vertex &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Symmetric matrices correspond to undirected graphs
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
What operation does Gaussian elimination imply on the graph?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;illustrative-example&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Illustrative example&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-ge.png&quot; class=&quot;center&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Gaussian elimination eliminates node &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; and connects all paths that go through &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; (all neighbors)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;illustrative-example-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Illustrative example&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
It is better to start elimination from leaves
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-ge-reorg.png&quot; class=&quot;center&quot; height=&quot;250&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
What if the matrix is not &lt;strong&gt;tree&lt;/strong&gt; structured?
&lt;ul&gt;
&lt;li&gt;
At least cluster nodes
&lt;/li&gt;
&lt;li&gt;
Postpone interaction of cluster to the end
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;dissection-of-a-regular-grid&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Dissection of a regular grid&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-nested.png&quot; class=&quot;center&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;reordered-matrix-based-on-dissection&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Reordered matrix based on dissection&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
A &amp;amp;= LU\\
L &amp;amp;=\begin{bmatrix} I &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; I &amp;amp; 0 \\A_{31}A_{11}^{-1}&amp;amp; A_{32}A_{22}^{-1} &amp;amp; I \\\end{bmatrix}\\
U &amp;amp;=\begin{bmatrix} A_{11} &amp;amp; 0 &amp;amp; A_{13} \\ 0 &amp;amp; A_{22} &amp;amp; A_{23} \\0 &amp;amp; 0 &amp;amp; S_{33} \\\end{bmatrix}\\
S_{33} &amp;amp;= A_{33} - A_{31}A_{11}^{-1}A_{13} - A_{32}A_{22}^{-1}A_{23}
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-dissection.png&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;nested-dissection&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Nested dissection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Recursively reorder sub-blocks until they are small
&lt;ul&gt;
&lt;li&gt;
Maintain the same &lt;strong&gt;&lt;em&gt;interior to boundary ratio&lt;/em&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;
Work on sub-domains in parallel
&lt;/li&gt;
&lt;li&gt;
combine results using the interface block
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interface matrix &lt;span class=&quot;math inline&quot;&gt;\(S_{33}\)&lt;/span&gt; is dense&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
For 2D, &lt;span class=&quot;math inline&quot;&gt;\(N=n\times n\)&lt;/span&gt; unknowns
&lt;ul&gt;
&lt;li&gt;
Storage: &lt;span class=&quot;math inline&quot;&gt;\(M(n) = 4M(\frac{n}{2}) + \frac{3}{2}n^2, M(N) = O(N\log N)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Time: &lt;span class=&quot;math inline&quot;&gt;\(C(n) = 4C(\frac{n}{2}) + \frac{5}{4}n^3, C(N) = O(N^{3/2})\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
For 3D, &lt;span class=&quot;math inline&quot;&gt;\(N=n\times n\times n\)&lt;/span&gt; unknowns
&lt;ul&gt;
&lt;li&gt;
Memory (fill-ins) &lt;span class=&quot;math inline&quot;&gt;\(O(N^{4/3})\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Cost &lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;graph-partitioning&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Graph Partitioning&lt;/h1&gt;
&lt;section id=&quot;graph-partitioning-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Graph partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Consider a weighted undirect graph &lt;span class=&quot;math inline&quot;&gt;\(G=(V,E,W_v, W_e)\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(W_v\)&lt;/span&gt; is the set of vertex weights
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(W_e\)&lt;/span&gt; is the set of edge weights
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Interpretation
&lt;ul&gt;
&lt;li&gt;
Nodes are tasks
&lt;/li&gt;
&lt;li&gt;
Node weights are task cost
&lt;/li&gt;
&lt;li&gt;
Edge are task dependencies/communication
&lt;/li&gt;
&lt;li&gt;
Edge weights are message size
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
Choose a partition &lt;span class=&quot;math inline&quot;&gt;\(V = V_1 \cup V_2 \dots \cup V_n\)&lt;/span&gt; such that
&lt;ul&gt;
&lt;li&gt;
The sum of the node weights in each &lt;span class=&quot;math inline&quot;&gt;\(V_j\)&lt;/span&gt; is &lt;em&gt;almost equal&lt;/em&gt;
&lt;/li&gt;
&lt;li&gt;
The sum of all weights for edges crossing the cuts is minimized
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We will consider bisection (recursively apply for more partitions)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NP-complete problem: &lt;span class=&quot;math inline&quot;&gt;\({n \choose n/2} \approx 2^n\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;applications-of-graph-partitioning&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Applications of graph partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Load balancing
&lt;/li&gt;
&lt;li&gt;
Sparse matvec
&lt;/li&gt;
&lt;li&gt;
Solving PDEs (e.g., Poisson’s equation)
&lt;/li&gt;
&lt;li&gt;
Physical networks (VLSI layout in circuit design)
&lt;/li&gt;
&lt;li&gt;
Sparse Gaussian elimination
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;vertex-and-edge-separators&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Vertex and Edge separators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Edge separator:&lt;/strong&gt; A set of edges &lt;span class=&quot;math inline&quot;&gt;\(E_s\)&lt;/span&gt;, if removed from &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt; disconnects the graph to two components with approximately same size&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vertex separator:&lt;/strong&gt; Set of vertices &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; that breaks the graph to two parts if removed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
One can be generated from the other
&lt;ul&gt;
&lt;li&gt;
Given &lt;span class=&quot;math inline&quot;&gt;\(E_s\)&lt;/span&gt; remove one end vertex of each edge
&lt;/li&gt;
&lt;li&gt;
Given &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; remove all incident edges
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;graphs-with-coordinate-information&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Graphs with coordinate information&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
E.g., graphs from discretization of PDEs
&lt;ul&gt;
&lt;li&gt;
Nodes are embedded in &lt;span class=&quot;math inline&quot;&gt;\(2D\)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;\(3D\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Nodes are connected to other &lt;strong&gt;&lt;em&gt;physically near&lt;/em&gt;&lt;/strong&gt; nodes
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;Theorem:&lt;/strong&gt; A planar graph has a vertex separator &lt;span class=&quot;math inline&quot;&gt;\(V_s\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(|V_s|\le \sqrt{8n}\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;inertial-partitioning&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Inertial partitioning&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Objective is to find a bisecting hyperplane&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Each vertex has a coordinate &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}_i\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Find the center of mass in space
&lt;/li&gt;
&lt;li&gt;
Find the line &lt;span class=&quot;math inline&quot;&gt;\(I_0\)&lt;/span&gt; that minimizes the sum of squared-distance of points (total least squares fit)
&lt;/li&gt;
&lt;li&gt;
Find the median hyperplane orthogonal to &lt;span class=&quot;math inline&quot;&gt;\(I_0\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;assets/dedicated-hpc18/img/09-inertial.png&quot; class=&quot;center fragment slide-pillar&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;coordinate-free-graphs&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Coordinate free graphs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
What can we do for coordinate free graphs?
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use BFS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BFS property: There is no edge between a node and its indirect descendants&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start from a random vertex &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and partition by distance from &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;greedy-refinement&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Greedy refinement&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size
&lt;ul&gt;
&lt;li&gt;
Exchange nodes that have most gain
&lt;/li&gt;
&lt;li&gt;
Stop when there is no positive gain
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;kernighan-lin-algorithm&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Consider an edge weighted graph &lt;span class=&quot;math inline&quot;&gt;\(W_v\equiv 1\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size
&lt;/li&gt;
&lt;li&gt;
Cost of current partitioning
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T = \sum_{p\in P, q\in Q} w(p,q) \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Cost of a vertex:
&lt;ul&gt;
&lt;li&gt;
External &lt;span class=&quot;math inline&quot;&gt;\(C_e(p) = \sum_{r\in Q} w(p,r)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Internal &lt;span class=&quot;math inline&quot;&gt;\(C_i(p) = \sum_{r\in P} w(p,r)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Moving vertex &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; from &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; changes &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;\(D(p) = C_i(p)-C_e(p)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Exchanging two vertices changes &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; by
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g(p,q) = D(p) + D(q) - 2w(p,q)\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;kernighan-lin-algorithm-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Start with a partition &lt;span class=&quot;math inline&quot;&gt;\(V=P\cup Q\)&lt;/span&gt; of similar size&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find a vertex pair that maximizes the gain &lt;span class=&quot;math inline&quot;&gt;\(g(p,q)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Store the gain function as &lt;span class=&quot;math inline&quot;&gt;\(g_k\)&lt;/span&gt; (&lt;span class=&quot;math inline&quot;&gt;\(g_k\)&lt;/span&gt; could be negative)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Mark &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; for swap and lock them (do not consider them for any future exchanges)
&lt;ul&gt;
&lt;li&gt;
Update &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; for all adjacent vertices (as if &lt;span class=&quot;math inline&quot;&gt;\(p,q\)&lt;/span&gt; were swapped)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterate until all vertices are locked&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find the index &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; that has the maximum partial sum &lt;span class=&quot;math inline&quot;&gt;\(\sum_{k=1}^m g_k\)&lt;/span&gt; and only apply those swaps&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/section&gt;
&lt;section id=&quot;kernighan-lin-algorithm-2&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Kernighan-Lin Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Cost
&lt;ul&gt;
&lt;li&gt;
Each selection is &lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Each pass is &lt;span class=&quot;math inline&quot;&gt;\(O(n^3)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Converges to (local) minimum in a few sweeps
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;spectral-partitioning&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Another way to formulate the graph bisection problem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find binary labeling &lt;span class=&quot;math inline&quot;&gt;\(x_u=\pm 1\)&lt;/span&gt; for vertex &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; such that its an even partitioning&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{u\in V} x_u = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use the value of the label for bisection&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edge cut cost&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f = \frac{1}{4} \sum_{(u,v)\in E} (x_u - x_v)^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;spectral-partitioning-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
The incidence matrix &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; is an &lt;span class=&quot;math inline&quot;&gt;\(n\times m\)&lt;/span&gt; matrix with one row for each node and one column for each vertex
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ C_{u,e} = \begin{cases}1 &amp;amp; e=(u,v)\\-1 &amp;amp; e=(v,u)\\0 &amp;amp; \text{otherwise} \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
The &lt;strong&gt;&lt;em&gt;Laplacian matrix&lt;/em&gt;&lt;/strong&gt; of the graph is an &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; matrix
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L_{u,v} = \begin{cases}d(u) &amp;amp; u=v\\-1 &amp;amp; (u,v)\in E\\0 &amp;amp; \text{otherwise} \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
It turns out &lt;span class=&quot;math inline&quot;&gt;\(L = CC^T\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;spectral-partitioning-2&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Spectral partitioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
The edge cut cost can be written
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f = \frac{1}{4} \| C^T x \|^2 = \frac{1}{4} x^T L x \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The relaxed problem is&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min x^T L x\qquad\text{subject to}\qquad x^T e = 0 \quad\text{and}\quad x^T x = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(e=(1,1,\dots,1)^T\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Equivalent to finding the second smallest eigenvalue of &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; and its corresponding eigenvector &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Partition based on the sign of &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expensive but high quality partition&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;large-graphs&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Large graphs&lt;/h2&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use a multilevel approach&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Contract the graph until small (use maximal matching)
&lt;/li&gt;
&lt;li&gt;
Partition the coarsest level
&lt;/li&gt;
&lt;li&gt;
Expand and use the partitioning as initial guess for an iterative refinement
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 29 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-09-graph.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-09-graph.html</guid>
      
      
      <category>lecture</category>
      
    </item>
    
    <item>
      <title>Final project</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt;
  &lt;title&gt;Final project&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Final project&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;/div&gt;
&lt;section id=&quot;final-project&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Final project&lt;/h1&gt;
&lt;p&gt;For your final, you are required to complete a project. The project’s topic and scope depend on your level (grad/undergrad) and your interests. Total cumulative credits for the project is about 300 points (different between graduate and undergraduate students).&lt;/p&gt;
&lt;section id=&quot;general-specification&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;General specification&lt;/h2&gt;
&lt;p&gt;Your final project should involve performance analysis of a specific algorithm. This analysis is either done through investigating performance of some particular code or method in a research paper or by explaining something about performance and parallelism in an instructional module. Meeting these general guidelines, you are free to propose whatever project topic you would like.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;project-proposal-topic-team&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Project proposal (topic &amp;amp; team)&lt;/h2&gt;
&lt;p&gt;You are strongly encouraged to work with a partner on the project. My suggestion is that one student in CSCI 5576 partners with a student in CSCI 4576. If you have an idea that interests you, writing a compelling proposal and sharing it with the class is a great way of finding a teammate.&lt;/p&gt;
&lt;p&gt;As we progress in the course, some other topic may pique your interest and you can switch topics.&lt;/p&gt;
&lt;p&gt;The purpose of the project proposal is to ensure that your project is neither too big nor too small and that we have a good variety of projects. You should explain the problem you will study and the methodologies you will use. That is, what analysis will you do, what data will you collect, and what will you build? Note that not all topics will require all three of those features, but you must demonstrate that you will think about something in an organized way.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Credits and due date: 40 points, November 6&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;paper-presentation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Paper Presentation&lt;/h2&gt;
&lt;p&gt;The paper presentation is required &lt;strong&gt;only&lt;/strong&gt; of students enrolled in CSCI 5576. All CSCI 5576 students must present a paper in HPC. Each person should present one paper.&lt;/p&gt;
&lt;p&gt;The purpose of the presentation is for you to study a paper and then share what you have learned with the class. &lt;strong&gt;&lt;em&gt;Educate us!&lt;/em&gt;&lt;/strong&gt; The presentation must address the following points. It will also be evaluated on style and accessibility.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Problem that the paper addresses,
&lt;/li&gt;
&lt;li&gt;
How the problem is solved,
&lt;/li&gt;
&lt;li&gt;
Major lessons learned,
&lt;/li&gt;
&lt;li&gt;
Followup (weaknesses, changes since the paper was written, extensions, etc.),
&lt;/li&gt;
&lt;li&gt;
Presentation length up to 10 minutes, followed by up to 2 minutes of questions and discussion,
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You’re expected to get about 10 minutes for your presentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Credits and due date: 50 points, TBD (late November)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;final-presentation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Final Presentation&lt;/h2&gt;
&lt;p&gt;The final presentation gives you the opportunity to share your work with the rest of the class. The presentation will be evaluated in terms of clarity and organization and how well you address the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
What was the problem you studied?
&lt;/li&gt;
&lt;li&gt;
What did you learn about its solution?
&lt;/li&gt;
&lt;li&gt;
What were the details of your approach? For example, if you studied parallel implementations of an algorithm, you might address questions like – How does the algorithm fit the selected architecture(s)? – What is an appropriate performance model?
&lt;/li&gt;
&lt;li&gt;
How well do the selected programming models express the algorithm? Here, you need to address what data you collected, what analysis you did, and what you built, if anything.
&lt;/li&gt;
&lt;li&gt;
What did you learn in this class that helped you most in your project?
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Larger groups will receive more time for their presentation. Partners should split the talking roughly equally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Credits and due date: 130 points, last week of class&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;final-report&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Final Report&lt;/h2&gt;
&lt;p&gt;The final paper, due at our final exam time, should be a well-written formal research report. This document must present the polished, final product of your research accurately and well, integrate and answer any comments and questions that were raised during the in-class presentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Credits and due date: 130 points, final day&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 15 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-final-project.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-final-project.html</guid>
      
      
      <category>assignment</category>
      
    </item>
    
    <item>
      <title>Sparse linear algebra</title>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot;&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Abtin Rahimian&quot;&gt;
  &lt;meta name=&quot;dcterms.date&quot; content=&quot;2017-10-16&quot;&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;title&gt;Sparse linear algebra&lt;/title&gt;
  &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/reveal.css&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/theme/white.css&quot; id=&quot;theme&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot;/&gt;
  &lt;!-- Printing and PDF exports --&gt;
  &lt;script&gt;
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'assets/js/reveal.js/css/print/pdf.css' : 'assets/js/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  &lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
  &lt;script src=&quot;assets/js/reveal.js/lib/js/html5shiv.js&quot;&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;reveal&quot;&gt;
    &lt;div class=&quot;slides&quot;&gt;

&lt;section&gt;
  &lt;h1 class=&quot;title&quot;&gt;Sparse linear algebra&lt;/h1&gt;
  &lt;p class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/p&gt;
  &lt;p class=&quot;author&quot;&gt;Abtin Rahimian&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;October 16, 2017&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;&lt;section id=&quot;introduction&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Introduction&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;recap&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Recap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BLAS, LAPACK, etc.&lt;/li&gt;
&lt;li&gt;Operations
&lt;ul&gt;
&lt;li&gt;Inner product&lt;/li&gt;
&lt;li&gt;Outer product &lt;span class=&quot;math inline&quot;&gt;\(A=x y^T\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Matrix-vector product (matvec &lt;span class=&quot;math inline&quot;&gt;\(y=y+Ax\)&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;Matrix-matrix product (matmul &lt;span class=&quot;math inline&quot;&gt;\(C=C+AB\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;Solving dense linear systems
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;LU/QR/Cholesky factorization&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;Time Complexity of factorization (2D block cyclic LU)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T_p = t_c \frac{n^3}{p} + 2 t_s n + t_w \frac{n^2}{\sqrt{p}}\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;If you double the problem size, you will need 8&lt;span class=&quot;math inline&quot;&gt;\(\times\)&lt;/span&gt; more compute power&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;agenda&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Agenda&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An example of sparse linear system&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterative method for (sparse matrices)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Stationary iterative methods,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Krylov subspace methods.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Resource:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterative Methods for Sparse Linear Systems, Saad&lt;br /&gt;
Available on SIAM website (through CU library)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;why-iterative-methods&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Why iterative methods&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot; style=&quot;flex: 1.5;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Methods such as Gaussian elimination (LU) compute the &lt;strong&gt;&lt;em&gt;exact solution&lt;/em&gt;&lt;/strong&gt; in full precision in finite number of steps
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(n^3\)&lt;/span&gt; is too much: it grows too fast &amp;amp; we only have &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; data and &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; data for sparse.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;We are not presenting numbers in full precision:
&lt;ul&gt;
&lt;li&gt;Single/double precision
&lt;ul&gt;
&lt;li&gt;There are gaps in representation&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Floating point numbers (exponent is kept separately, gaps are proportional)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(1, 1+2^{-52}, 1+2\times 2^{-52}, 1+3\times 2^{-52}, \dots, 2\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Machine accuracy &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_\text{double} \approx 1.11 \times 10^{-16}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;See, Numerical Linear Algebra (Trefethen, Bau), Chap. 13.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-cost.png&quot; alt=&quot;Accuracy vs. cost&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;figcaption&gt;Accuracy vs. cost&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;How fast can we solve the problem if we loosen our “exactness” requirement?&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;iterative-methods&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Iterative methods&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;definitions&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ax = b.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[e = y - x \quad (x: \text{candidate solution}, y:\text{true solution}).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Residual&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[r = b - Ax.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Convergence criteria&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\|r\|\le \epsilon \quad \text{or} \quad \|r\|\le \epsilon_r \|b\| + \epsilon_a.\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;note-residual-is-not-error&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Note: residual is not error&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Residual &lt;span class=&quot;math inline&quot;&gt;\(r = b - Ax,\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Error &lt;span class=&quot;math inline&quot;&gt;\(e = y - x,\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
e &amp;amp;= y - x, \\ A e &amp;amp;= Ay -Ax, \\&amp;amp;= b - A x \\&amp;amp;= r,\\
\| e \| &amp;amp;= \frac{1}{\|A\|} \|r\|.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;iterative-methods-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Iterative methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Start with an approximate solution,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iteratively improve (reduce residual) until convergence (&lt;span class=&quot;math inline&quot;&gt;\(\|r\|\le \epsilon_r \|b\| + \epsilon_a\)&lt;/span&gt;),&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cost&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{(number of iterations)} \times \text{(cost of matvec)}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Does not require instantiation of the whole matrix&lt;/em&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Suitable for matrix-free methods&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;example-of-sparse-system&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Example of sparse system&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;poissons-equation&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Poisson’s Equation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;You were introduced the Poisson’s equation in the previous lab assignment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} a u - \Delta u &amp;amp;= f &amp;amp;&amp;amp;\text{for}\quad x\in B\\ u(x) &amp;amp;= 0 &amp;amp;&amp;amp;\text{for}\quad x\in \partial B\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is an example of boundary value problem&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;solving-1d-poissons-equation&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Solving 1D Poisson’s equation&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} -\frac{d^2 u}{dx^2}  &amp;amp;= f &amp;amp;&amp;amp;\text{for}\quad x\in (0,1)\\ u(0) &amp;amp;= u(1) = 0\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Discretize the problem by estimating the solution at &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(h = 1/(N-1),\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_i = i h, 0\le i &amp;lt; n,\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(u_i = u(x_i), \mathsf{u} = [u_0, u_1, \dots, u_{N-1}],\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_i = f(x_i), \mathsf{f} = [f_0, f_1, \dots, f_{N-1}].\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-poisson-1d-disc.png&quot; alt=&quot;Discretization points in 1D domain&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Discretization points in 1D domain&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;&lt;section id=&quot;finite-differences&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Finite differences&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use finite differences to estimate derivatives&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-poisson-1d.png&quot; alt=&quot;Finite differences&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Finite differences&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class=&quot;smaller&quot; style=&quot;margin-top:-1.5em;&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\left.\frac{d u}{d x}\right|_{x_i} &amp;amp;= \frac{u_{i}-u_{i-1}}{h} + e_1(x_i), &amp;amp;
\left.\frac{d u}{d x}\right|_{x_i} &amp;amp;= \frac{u_{i+1}-u_{i}}{h} + e_1&amp;#39;(x_i), &amp;amp;\\
\left.\frac{d^2 u}{d x^2}\right|_{x_i} &amp;amp;= \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^2} + e_t(x_i), &amp;amp;e_t &amp;amp;= O\Big(h^2 u^{(4)}(x_i)\Big). &amp;amp;
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;linear-system-for-1d-poissons&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Linear system for 1D Poisson’s&lt;/h2&gt;
&lt;p&gt;Writing the discrete equation we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
-\frac{u_{i+1}+u_{i-1}-2u_i}{h^2} &amp;amp;= f_i \quad (1\le i &amp;lt;N-2),\\
u_0 &amp;amp;= 0, \\
u_{N-1} &amp;amp;= 0, \\
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;linear-system-for-1d-poissons-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Linear system for 1D Poisson’s&lt;/h2&gt;
&lt;p&gt;In matrix form we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
\begin{bmatrix}
1       &amp;amp; 0         &amp;amp;           &amp;amp;               &amp;amp;           &amp;amp;    \\
-1      &amp;amp; 2         &amp;amp; -1        &amp;amp;               &amp;amp;           &amp;amp;    \\
0       &amp;amp; -1        &amp;amp; 2         &amp;amp; -1            &amp;amp;           &amp;amp;    \\
        &amp;amp;           &amp;amp;\ddots     &amp;amp;\ddots         &amp;amp;\ddots     &amp;amp;    \\
        &amp;amp;           &amp;amp;           &amp;amp; -1            &amp;amp; 2         &amp;amp; -1 \\
        &amp;amp;           &amp;amp;           &amp;amp;               &amp;amp; 0         &amp;amp;  1 \\
\end{bmatrix}
\begin{bmatrix}
 u_0\\u_1\\u_2\\\vdots\\u_{N-2}\\u_{N-1}
 \end{bmatrix}
=
h^2
\begin{bmatrix}
0\\f_1\\f_2\\\vdots\\f_{N-2}\\0
\end{bmatrix},
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or more compactly&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathsf{A u = f}. \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;solving-2d-poissons-equation&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Solving 2D Poisson’s equation&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*} -\frac{\partial^2 u}{\partial x^2} -\frac{\partial^2
u}{\partial y^2} &amp;amp;= f \quad\text{for}\quad x\in (0,1)\times(0,1)\\
u(0,y) &amp;amp;= u(1,y) = u(x,0) = u(x,1) = 0\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discretize using similar approach to 1D&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\left.\frac{\partial^2 u}{\partial x^2}\right|_{x_i,y_i} &amp;amp;= \frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{h^2},\\
\left.\frac{\partial^2 u}{\partial y^2}\right|_{x_i,y_i} &amp;amp;= \frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{h^2}.\\
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-poisson-2d.png&quot; alt=&quot;Five-point stencil&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;figcaption&gt;Five-point stencil&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;solving-2d-poissons-equation-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Solving 2D Poisson’s equation&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Delta u|_{i,j} = \frac{u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}-4u_{i,j}}{h^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let &lt;span class=&quot;math inline&quot;&gt;\(\mathsf{u}\)&lt;/span&gt; denote the vector containing samples of &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; on the grid points
&lt;ul&gt;
&lt;li&gt;For example, on an &lt;span class=&quot;math inline&quot;&gt;\(N\times N\)&lt;/span&gt; grid with row-major ordering &lt;span class=&quot;math inline&quot;&gt;\(\mathsf{u}[iN+j] = u_{i,j}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In matrix form, We have&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathsf{Au} = h^2 \mathsf{f}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathsf{A}\)&lt;/span&gt; is sparse&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-poisson-2d-mat.png&quot; alt=&quot;Sparse matrices&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;figcaption&gt;Sparse matrices&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;solving-3d-poissons-equation&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Solving 3D Poisson’s equation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Matvec and residual: this assignment&lt;/li&gt;
&lt;li&gt;Iterative solve: next assignment&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;stationary-iterative-methods&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Stationary iterative methods&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;contractions&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Contractions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A function &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; is a contraction if&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\| f(x)-f(y) \| \le c \|x-y\|, \quad c&amp;lt;1.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; has a unique fixed point &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(f(x^\star) = x^\star,\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Starting form any point &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt; define the sequence &lt;span class=&quot;math inline&quot;&gt;\(x^{k+1} = f(x^k)\)&lt;/span&gt;, then &lt;span class=&quot;math inline&quot;&gt;\(x^k \to x^\star,\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rate of convergence depends on rate of contraction &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;stationary-iterative-methods-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Stationary iterative methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Cast the solution of the linear system &lt;span class=&quot;math inline&quot;&gt;\(Ax = b\)&lt;/span&gt; as finding the fixed point of a contraction.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Write &lt;span class=&quot;math inline&quot;&gt;\(A= M - K\)&lt;/span&gt;, then&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
    M x &amp;amp;= Kx + b,\\
    x^{k+1} &amp;amp;= M^{-1}(K x^k + b),\\
    x^{k+1} &amp;amp;= G x^k + c.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Converges if &lt;span class=&quot;math inline&quot;&gt;\(\rho(G)&amp;lt;1\)&lt;/span&gt; (the spectral radius of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;), i.e., the largest eigenvalue of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; has magnitude less than one implying that &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; is a contraction.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Error &lt;span class=&quot;math inline&quot;&gt;\(e^k = x^k - x^\star\)&lt;/span&gt; satisfies &lt;span class=&quot;math inline&quot;&gt;\(e^{k+1} = G e^k\)&lt;/span&gt; (why?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterative methods of this form are called stationary because the transition from &lt;span class=&quot;math inline&quot;&gt;\(x_k\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(x_{k+1}\)&lt;/span&gt; &lt;strong&gt;&lt;em&gt;does not depend on the history of the iteration&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;stationary-iterative-methods-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Stationary iterative methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Different choices of &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; imply different convergence rates
&lt;ul&gt;
&lt;li&gt;Cheapest (maybe not convergent) &lt;span class=&quot;math inline&quot;&gt;\(M=I.\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Fastest (most expensive) &lt;span class=&quot;math inline&quot;&gt;\(M=A.\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Well-known methods
&lt;ul&gt;
&lt;li&gt;Richardson iteration,&lt;/li&gt;
&lt;li&gt;Jacobi,&lt;/li&gt;
&lt;li&gt;Gauss-Seidel,&lt;/li&gt;
&lt;li&gt;Successive over-relaxation (SOR).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;richardson-iteration&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Richardson Iteration&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Choose &lt;span class=&quot;math inline&quot;&gt;\(M=\frac{1}{\omega} I, K=M-A\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = M^{-1}(Kx^k + b) = x^{k} + \omega (b - Ax^k )= (I-\omega A)x^k + \omega b, \]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Richardson iteration with a small enough &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; will eventually converge
&lt;ul&gt;
&lt;li&gt;As long as all the eigenvalues of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; have positive real part,&lt;/li&gt;
&lt;li&gt;That &lt;strong&gt;&lt;em&gt;eventuality may take a very long time&lt;/em&gt;&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;Assume all eigenvalues of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; are positive &lt;span class=&quot;math inline&quot;&gt;\(\lambda_\text{min}&amp;gt;0\)&lt;/span&gt;, which &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; provides the fastest rate of convergence?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
  \rho(G) &amp;amp;= \max(|1-\omega \lambda_\text{min}|,|1-\omega \lambda_\text{max}|),\\
  \omega_\text{opt} &amp;amp;= 2/(\lambda_\text{max}+\lambda_\text{min}),\\
  \rho_\text{opt}(G) &amp;amp;= \frac{\lambda_\text{max}-\lambda_\text{min}}{\lambda_\text{max}+\lambda_\text{min}}.
  \end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Very slow convergence in presence of small and large eigenvalues.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;jacobi-method&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Jacobi method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Choose &lt;span class=&quot;math inline&quot;&gt;\(M = \mathrm{diag}(A), K = M-A\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = M^{-1}(Kx^k+b)\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Requires nonzero diagonal entries, which can usually be accomplished by permuting rows and columns if not already true,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Requires duplicate storage for &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Convergence rate may be very slow
&lt;ul&gt;
&lt;li&gt;Does not always converge,&lt;/li&gt;
&lt;li&gt;Converges if matrix is strictly diagonally dominant.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;gauss-seidel-method&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gauss-Seidel method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Jacobi method per element:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1}_i = \frac{1}{a_{ii}}\Big(b_i-\sum_{j\ne i} a_{ij}x^k_j\Big).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We may get better convergence, if use the most recent value for &lt;span class=&quot;math inline&quot;&gt;\(x_j,\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In matrix form let &lt;span class=&quot;math inline&quot;&gt;\(A=L+U+D\)&lt;/span&gt; (strictly lower/upper triangular and diagonal):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}M &amp;amp;= L+D, \qquad K = -U,\\
x^{k+1}_i &amp;amp;= (L+D)^{-1}(b-Ux^{k}) = -(L+D)^{-1} Ux^{k} + (L+D)^{-1}b.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;gauss-seidel-method-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gauss-Seidel method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Requires nonzero diagonal entries (may require row/column permutation),&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Does not require duplicate storage for &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Does not always converge, it converges under conditions somewhat weaker than Jacobi,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Converges about twice as fast as Jacobi, but may still be very slow.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;sor-method&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;SOR method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the next Gauss-Seidel as search direction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x^{k+1} = x^{k} + \omega \Big(x^{k+1}_{GS}-x^k \Big).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; is a fixed &lt;em&gt;relaxation&lt;/em&gt; parameter
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega&amp;gt;1\)&lt;/span&gt;: over-relaxation,&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega&amp;lt;1\)&lt;/span&gt;: under-relaxation,&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega=1\)&lt;/span&gt;: Gauss-Seidel,&lt;/li&gt;
&lt;li&gt;Choosing optimal &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; is difficult.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Converges much faster than Gauss-Seidel (with the optimal choice of &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;krylov-subspace-methods&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Krylov subspace methods&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;non-stationary-methods&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Non-stationary methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How can we solve &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; if we only know &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; as black-box operator (can only do matvec)
&lt;ul&gt;
&lt;li&gt;This happens often in practice,&lt;/li&gt;
&lt;li&gt;Matvec is the cheapest nontrivial matrix operation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If matvec is all you can do, let’s keep multiplying&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{K}_m(A,v) = \Big\{ v, Av, A^2v, \dots, A^{m-1} v \Big\}. \]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;What is the best approximation to the true solution &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_m,\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;If the residual is large, look for approximation in &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_{m+1}.\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;There are many different Krylov subspace methods (KSP)
&lt;ul&gt;
&lt;li&gt;They have different assumptions about the matrix structure (symmetric, non-symmetric, etc.),&lt;/li&gt;
&lt;li&gt;Different rate of convergence.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;which-ksp&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Which KSP?&lt;/h2&gt;
&lt;p&gt;Consult “Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods”&lt;/p&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-which-ksp.png&quot; alt=&quot;Which KSP&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Which KSP&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;&lt;section id=&quot;preliminaries&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Preliminaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Inner product for &lt;span class=&quot;math inline&quot;&gt;\(u,v\in \mathbb{R}^n\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v) = v^T u, \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Positive definite matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (Au,u) &amp;gt; 0 \quad\text{for all}\quad x\ne 0,\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Condition number (SPD matrix)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\kappa(A) = \frac{|\lambda_\text{max}|}{|\lambda_\text{min}|},\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Weighted inner product for SPD matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v)_A = (u,Av) = v^TAu,\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;preliminaries-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Preliminaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Conjugate vectors with respect to SPD matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; (&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate)
&lt;ul&gt;
&lt;li&gt;When &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; are orthogonal with respect to the inner product defined by &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v)_A = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Suppose we have a set of &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; mutually &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate vectors&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(A) = \Big\{ p^i : (p^i,p^j)_A=0~\text{for}~i\ne j \Big\},\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(A)\)&lt;/span&gt; is a basis for &lt;span class=&quot;math inline&quot;&gt;\(R^n\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Any vector, including the solution to the linear system &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; can be represented in that basis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^\star = \sum_{i=1}^n \alpha_i p^i.\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;projection-method&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Projection method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finding the solution to &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; is equivalent to finding &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;slide-pillars group&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
    Ax^\star &amp;amp;= b,\\
    \sum_i \alpha_i Ap^i &amp;amp;= b,\\
    \left(p^j, \sum_i \alpha_i Ap^i\right) &amp;amp;=\left(b,p^j\right),
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\sum_i \alpha_i \left(p^j,p^i\right)_A &amp;amp;=\left(b,p^j\right), \\
\alpha_j &amp;amp;= \frac{\left(b,p^j\right)}{\left(p^j,p^j\right)_A}.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Done only if we knew &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate vectors
&lt;ul&gt;
&lt;li&gt;What is the cost of finding the solution in that case?&lt;/li&gt;
&lt;li&gt;Can we construct them?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;conjugate-gradient&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Conjugate gradient&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The solution to &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; is the minimizer for this quadratic form&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(x) = (x,Ax) - (x,b) = \frac{1}{2} x^T A x - x^T b.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla \phi(x) = \frac{1}{2} A x  + \frac{1}{2} A^T x - b  = Ax - b.\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;conjugate-gradient-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Conjugate gradient&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;For the initial guess &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt;, the steepest descent direction is &lt;span class=&quot;math inline&quot;&gt;\(-\nabla \phi(x^0)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[-\nabla \phi(x^0) = b - Ax^0 = r^0, \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This relationship is also true for any future descent direction:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[-\nabla \phi(x^k) = b - Ax^k = r^k.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let &lt;span class=&quot;math inline&quot;&gt;\(p^0 = r^0\)&lt;/span&gt; and construct a set of conjugate vectors iteratively using the descent direction.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;conjugate-gradient-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Conjugate gradient&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Given &lt;span class=&quot;math inline&quot;&gt;\(r^k, (k=0,\dots,n)\)&lt;/span&gt;, compute the &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;th conjugate vector by Gram-Schmidt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ p^k = r^k - \sum_{i&amp;lt;k} \frac{(r^k,p^k)_A}{(p^i,p^i)_A} p^i \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The next solution candidate is&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = x^k + \alpha_k p^k\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We had a formula for the coefficient &lt;span class=&quot;math inline&quot;&gt;\(\alpha_k\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\alpha_k = \frac{\left(b,p^k\right)}{\left(p^k,p^k\right)_A} = \frac{\left(r^{k-1}+Ax^{k-1},p^k\right)}{\left(p^k,p^k\right)_A} = \frac{\left(r^{k-1},p^k\right)}{\left(p^k,p^k\right)_A}.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The last simplification is because &lt;span class=&quot;math inline&quot;&gt;\(x^{k-1}\)&lt;/span&gt; is in the range of &lt;span class=&quot;math inline&quot;&gt;\(p^0,\dots,p^{k-1}\)&lt;/span&gt; that are &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate to &lt;span class=&quot;math inline&quot;&gt;\(p^k\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;cg-features&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;CG Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Has a short recurrence
&lt;ul&gt;
&lt;li&gt;Can compute the residual &lt;span class=&quot;math inline&quot;&gt;\(r^{k+1}\)&lt;/span&gt; from &lt;span class=&quot;math inline&quot;&gt;\(p^k,\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p^{k+1}\)&lt;/span&gt; only requires &lt;span class=&quot;math inline&quot;&gt;\(r^{k+1},\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Four vectors need to be stored &lt;span class=&quot;math inline&quot;&gt;\(x, p, r, Ap.\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It guarantees to converge in &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; step (in full precision)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Convergence rate&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1 }. \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;what-if-the-matrix-is-not-spd&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;What if the matrix is not SPD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Minimize &lt;span class=&quot;math inline&quot;&gt;\(\|Ax -b\|^2\)&lt;/span&gt; over &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_m(A, b)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Generalized Minimum RESidual (GMRES).&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;preconditioning&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Preconditioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Convergence rate of KSP solvers depend on the condition number of the matrix
&lt;ul&gt;
&lt;li&gt;Demo time (&lt;code&gt;Poisson&lt;/code&gt; python notebook)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Instead of solving &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;, if we use a matrix &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(\kappa(MA)&amp;lt;\kappa(A)\)&lt;/span&gt; we can improve the convergence rate&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ MAx = Mb. \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(M=A^{-1}\)&lt;/span&gt; is the perfect preconditioner&lt;/li&gt;
&lt;li&gt;The closer &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; is to &lt;span class=&quot;math inline&quot;&gt;\(A^{-1}\)&lt;/span&gt; the better&lt;/li&gt;
&lt;li&gt;Use approximate inverses of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Incomplete LU (ILU),&lt;/li&gt;
&lt;li&gt;Incomplete Cholesky (IC),&lt;/li&gt;
&lt;li&gt;Use knowledge of the problem.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;parallelization&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallelization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Required operations
&lt;ul&gt;
&lt;li&gt;matvec,&lt;/li&gt;
&lt;li&gt;vector update (&lt;code&gt;axpy&lt;/code&gt;),&lt;/li&gt;
&lt;li&gt;inner product (reduction).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need to decide how to partition data (the sparse matrix).&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;partitioning-for-iterative-solvers&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Partitioning for iterative solvers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Block partitioning of a sparse matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; is bad, some processors may not have any work,&lt;/li&gt;
&lt;li&gt;Row/column partitioning is better,&lt;/li&gt;
&lt;li&gt;Data locality can be achieved by,
&lt;ul&gt;
&lt;li&gt;Partitioning graph of matrix,&lt;/li&gt;
&lt;li&gt;Partitioning underlying grid or mesh for finite difference or finite element problem.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;summary&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;summary-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Iterative methods for solving linear system &lt;span class=&quot;math inline&quot;&gt;\(Ax = b\)&lt;/span&gt; begin with initial guess for solution and successively improve it until solution is as accurate as desired.&lt;/li&gt;
&lt;li&gt;Iterations terminate when residual &lt;span class=&quot;math inline&quot;&gt;\(\|b-Ax\|\)&lt;/span&gt;, or some other measure of error, is as small as desired,&lt;/li&gt;
&lt;li&gt;Iterative methods are especially useful when matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; is sparse because, unlike direct methods, no fill-in is incurred.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;which-ksp-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Which KSP?&lt;/h2&gt;
&lt;p&gt;Consult “Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods”&lt;/p&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/07-which-ksp.png&quot; alt=&quot;Which KSP&quot; class=&quot;plain&quot; style=&quot;width: 50%;&quot; /&gt;&lt;figcaption&gt;Which KSP&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;&lt;/section&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script src=&quot;assets/js/reveal.js/lib/js/head.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;assets/js/reveal.js/js/reveal.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Display the page number of the current slide
        slideNumber: 'c',
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Enables touch navigation on devices with touch input
        touch: true,
        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom
        // The &quot;normal&quot; size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 720,


      // Optional reveal.js plugins
      dependencies: [
          { src: 'assets/js/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'assets/js/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'assets/js/reveal.js/plugin/notes/notes.js', async: true }
      ]
      });
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 15 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-08-sparsela.sl.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-08-sparsela.sl.html</guid>
      
      
      <category>lecture</category>
      
    </item>
    
    <item>
      <title>Sparse linear algebra</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Abtin Rahimian&quot; /&gt;
  &lt;meta name=&quot;date&quot; content=&quot;2017-10-16&quot; /&gt;
  &lt;title&gt;Sparse linear algebra&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Sparse linear algebra&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Abtin Rahimian&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;October 16, 2017&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;introduction&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;section id=&quot;recap&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Recap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
BLAS, LAPACK, etc.
&lt;/li&gt;
&lt;li&gt;
Operations
&lt;ul&gt;
&lt;li&gt;
Inner product
&lt;/li&gt;
&lt;li&gt;
Outer product &lt;span class=&quot;math inline&quot;&gt;\(A=x y^T\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Matrix-vector product (matvec &lt;span class=&quot;math inline&quot;&gt;\(y=y+Ax\)&lt;/span&gt;)
&lt;/li&gt;
&lt;li&gt;
Matrix-matrix product (matmul &lt;span class=&quot;math inline&quot;&gt;\(C=C+AB\)&lt;/span&gt;)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
Solving dense linear systems
&lt;ul&gt;
&lt;li&gt;
LU/QR/Cholesky factorization
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Time Complexity of factorization (2D block cyclic LU)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T_p = t_c \frac{n^3}{p} + 2 t_s n + t_w \frac{n^2}{\sqrt{p}}\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;If you double the problem size, you will need 8&lt;span class=&quot;math inline&quot;&gt;\(\times\)&lt;/span&gt; more compute power&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/section&gt;
&lt;section id=&quot;agenda&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Agenda&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An example of sparse linear system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterative method for (sparse matrices)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Stationary iterative methods,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Krylov subspace methods.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resource:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Iterative Methods for Sparse Linear Systems, Saad&lt;br /&gt;
Available on SIAM website (through CU library)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;why-iterative-methods&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Why iterative methods&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot; style=&quot;flex: 1.5;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Methods such as Gaussian elimination (LU) compute the &lt;strong&gt;&lt;em&gt;exact solution&lt;/em&gt;&lt;/strong&gt; in full precision in finite number of steps
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(n^3\)&lt;/span&gt; is too much: it grows too fast &amp;amp; we only have &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; data and &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; data for sparse.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
We are not presenting numbers in full precision:
&lt;ul&gt;
&lt;li&gt;
Single/double precision
&lt;ul&gt;
&lt;li&gt;
There are gaps in representation
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Floating point numbers (exponent is kept separately, gaps are proportional)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(1, 1+2^{-52}, 1+2\times 2^{-52}, 1+3\times 2^{-52}, \dots, 2\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Machine accuracy &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_\text{double} \approx 1.11 \times 10^{-16}\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
See, Numerical Linear Algebra (Trefethen, Bau), Chap. 13.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-cost.png&quot; alt=&quot;Accuracy vs. cost&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;figcaption&gt;Accuracy vs. cost&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
How fast can we solve the problem if we loosen our “exactness” requirement?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;iterative-methods&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Iterative methods&lt;/h1&gt;
&lt;section id=&quot;definitions&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Linear system
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ax = b.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Error
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[e = y - x \quad (x: \text{candidate solution}, y:\text{true solution}).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Residual
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[r = b - Ax.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Convergence criteria
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\|r\|\le \epsilon \quad \text{or} \quad \|r\|\le \epsilon_r \|b\| + \epsilon_a.\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;note-residual-is-not-error&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Note: residual is not error&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Residual &lt;span class=&quot;math inline&quot;&gt;\(r = b - Ax,\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Error &lt;span class=&quot;math inline&quot;&gt;\(e = y - x,\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
e &amp;amp;= y - x, \\ A e &amp;amp;= Ay -Ax, \\&amp;amp;= b - A x \\&amp;amp;= r,\\
\| e \| &amp;amp;= \frac{1}{\|A\|} \|r\|.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;iterative-methods-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Iterative methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Start with an approximate solution,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iteratively improve (reduce residual) until convergence (&lt;span class=&quot;math inline&quot;&gt;\(\|r\|\le \epsilon_r \|b\| + \epsilon_a\)&lt;/span&gt;),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cost&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{(number of iterations)} \times \text{(cost of matvec)}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;&lt;em&gt;Does not require instantiation of the whole matrix&lt;/em&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;
Suitable for matrix-free methods
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;example-of-sparse-system&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Example of sparse system&lt;/h1&gt;
&lt;section id=&quot;poissons-equation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Poisson’s Equation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
You were introduced the Poisson’s equation in the previous lab assignment
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} a u - \Delta u &amp;amp;= f &amp;amp;&amp;amp;\text{for}\quad x\in B\\ u(x) &amp;amp;= 0 &amp;amp;&amp;amp;\text{for}\quad x\in \partial B\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
This is an example of boundary value problem
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;solving-1d-poissons-equation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Solving 1D Poisson’s equation&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} -\frac{d^2 u}{dx^2}  &amp;amp;= f &amp;amp;&amp;amp;\text{for}\quad x\in (0,1)\\ u(0) &amp;amp;= u(1) = 0\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Discretize the problem by estimating the solution at &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(h = 1/(N-1),\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(x_i = i h, 0\le i &amp;lt; n,\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(u_i = u(x_i), \mathsf{u} = [u_0, u_1, \dots, u_{N-1}],\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(f_i = f(x_i), \mathsf{f} = [f_0, f_1, \dots, f_{N-1}].\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-poisson-1d-disc.png&quot; alt=&quot;Discretization points in 1D domain&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Discretization points in 1D domain&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;
&lt;section id=&quot;finite-differences&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Finite differences&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Use finite differences to estimate derivatives
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-poisson-1d.png&quot; alt=&quot;Finite differences&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Finite differences&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class=&quot;smaller&quot; style=&quot;margin-top:-1.5em;&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\left.\frac{d u}{d x}\right|_{x_i} &amp;amp;= \frac{u_{i}-u_{i-1}}{h} + e_1(x_i), &amp;amp;
\left.\frac{d u}{d x}\right|_{x_i} &amp;amp;= \frac{u_{i+1}-u_{i}}{h} + e_1&amp;#39;(x_i), &amp;amp;\\
\left.\frac{d^2 u}{d x^2}\right|_{x_i} &amp;amp;= \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^2} + e_t(x_i), &amp;amp;e_t &amp;amp;= O\Big(h^2 u^{(4)}(x_i)\Big). &amp;amp;
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;linear-system-for-1d-poissons&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Linear system for 1D Poisson’s&lt;/h2&gt;
&lt;p&gt;Writing the discrete equation we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
-\frac{u_{i+1}+u_{i-1}-2u_i}{h^2} &amp;amp;= f_i \quad (1\le i &amp;lt;N-2),\\
u_0 &amp;amp;= 0, \\
u_{N-1} &amp;amp;= 0, \\
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In matrix form we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
\begin{bmatrix}
1       &amp;amp; 0         &amp;amp;           &amp;amp;               &amp;amp;           &amp;amp;    \\
-1      &amp;amp; 2         &amp;amp; -1        &amp;amp;               &amp;amp;           &amp;amp;    \\
0       &amp;amp; -1        &amp;amp; 2         &amp;amp; -1            &amp;amp;           &amp;amp;    \\
        &amp;amp;           &amp;amp;\ddots     &amp;amp;\ddots         &amp;amp;\ddots     &amp;amp;    \\
        &amp;amp;           &amp;amp;           &amp;amp; -1            &amp;amp; 2         &amp;amp; -1 \\
        &amp;amp;           &amp;amp;           &amp;amp;               &amp;amp; 0         &amp;amp;  1 \\
\end{bmatrix}
\begin{bmatrix}
 u_0\\u_1\\u_2\\\vdots\\u_{N-2}\\u_{N-1}
 \end{bmatrix}
=
h^2
\begin{bmatrix}
0\\f_1\\f_2\\\vdots\\f_{N-2}\\0
\end{bmatrix},
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or more compactly&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathsf{A u = f}. \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;solving-2d-poissons-equation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Solving 2D Poisson’s equation&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*} -\frac{\partial^2 u}{\partial x^2} -\frac{\partial^2
u}{\partial y^2} &amp;amp;= f \quad\text{for}\quad x\in (0,1)\times(0,1)\\
u(0,y) &amp;amp;= u(1,y) = u(x,0) = u(x,1) = 0\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Discretize using similar approach to 1D
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\left.\frac{\partial^2 u}{\partial x^2}\right|_{x_i,y_i} &amp;amp;= \frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{h^2},\\
\left.\frac{\partial^2 u}{\partial y^2}\right|_{x_i,y_i} &amp;amp;= \frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{h^2}.\\
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-poisson-2d.png&quot; alt=&quot;Five-point stencil&quot; class=&quot;center&quot; width=&quot;600&quot; /&gt;&lt;figcaption&gt;Five-point stencil&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Delta u|_{i,j} = \frac{u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}-4u_{i,j}}{h^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Let &lt;span class=&quot;math inline&quot;&gt;\(\mathsf{u}\)&lt;/span&gt; denote the vector containing samples of &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; on the grid points
&lt;ul&gt;
&lt;li&gt;
For example, on an &lt;span class=&quot;math inline&quot;&gt;\(N\times N\)&lt;/span&gt; grid with row-major ordering &lt;span class=&quot;math inline&quot;&gt;\(\mathsf{u}[iN+j] = u_{i,j}\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
In matrix form, We have
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathsf{Au} = h^2 \mathsf{f}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(\mathsf{A}\)&lt;/span&gt; is sparse
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-poisson-2d-mat.png&quot; alt=&quot;Sparse matrices&quot; class=&quot;center&quot; width=&quot;500&quot; /&gt;&lt;figcaption&gt;Sparse matrices&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;solving-3d-poissons-equation&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Solving 3D Poisson’s equation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Matvec and residual: this assignment
&lt;/li&gt;
&lt;li&gt;
Iterative solve: next assignment
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;stationary-iterative-methods&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Stationary iterative methods&lt;/h1&gt;
&lt;section id=&quot;contractions&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Contractions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
A function &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; is a contraction if
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\| f(x)-f(y) \| \le c \|x-y\|, \quad c&amp;lt;1.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; has a unique fixed point &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(f(x^\star) = x^\star,\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Starting form any point &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt; define the sequence &lt;span class=&quot;math inline&quot;&gt;\(x^{k+1} = f(x^k)\)&lt;/span&gt;, then &lt;span class=&quot;math inline&quot;&gt;\(x^k \to x^\star,\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rate of convergence depends on rate of contraction &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;stationary-iterative-methods-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Stationary iterative methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;&lt;em&gt;Cast the solution of the linear system &lt;span class=&quot;math inline&quot;&gt;\(Ax = b\)&lt;/span&gt; as finding the fixed point of a contraction.&lt;/em&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Write &lt;span class=&quot;math inline&quot;&gt;\(A= M - K\)&lt;/span&gt;, then
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
    M x &amp;amp;= Kx + b,\\
    x^{k+1} &amp;amp;= M^{-1}(K x^k + b),\\
    x^{k+1} &amp;amp;= G x^k + c.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Converges if &lt;span class=&quot;math inline&quot;&gt;\(\rho(G)&amp;lt;1\)&lt;/span&gt; (the spectral radius of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;), i.e., the largest eigenvalue of &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; has magnitude less than one implying that &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; is a contraction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Error &lt;span class=&quot;math inline&quot;&gt;\(e^k = x^k - x^\star\)&lt;/span&gt; satisfies &lt;span class=&quot;math inline&quot;&gt;\(e^{k+1} = G e^k\)&lt;/span&gt; (why?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterative methods of this form are called stationary because the transition from &lt;span class=&quot;math inline&quot;&gt;\(x_k\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(x_{k+1}\)&lt;/span&gt; &lt;strong&gt;&lt;em&gt;does not depend on the history of the iteration&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
Different choices of &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; imply different convergence rates
&lt;ul&gt;
&lt;li&gt;
Cheapest (maybe not convergent) &lt;span class=&quot;math inline&quot;&gt;\(M=I.\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Fastest (most expensive) &lt;span class=&quot;math inline&quot;&gt;\(M=A.\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Well-known methods
&lt;ul&gt;
&lt;li&gt;
Richardson iteration,
&lt;/li&gt;
&lt;li&gt;
Jacobi,
&lt;/li&gt;
&lt;li&gt;
Gauss-Seidel,
&lt;/li&gt;
&lt;li&gt;
Successive over-relaxation (SOR).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;richardson-iteration&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Richardson Iteration&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Choose &lt;span class=&quot;math inline&quot;&gt;\(M=\frac{1}{\omega} I, K=M-A\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = M^{-1}(Kx^k + b) = x^{k} + \omega (b - Ax^k )= (I-\omega A)x^k + \omega b, \]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Richardson iteration with a small enough &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; will eventually converge
&lt;ul&gt;
&lt;li&gt;
As long as all the eigenvalues of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; have positive real part,
&lt;/li&gt;
&lt;li&gt;
That &lt;strong&gt;&lt;em&gt;eventuality may take a very long time&lt;/em&gt;&lt;/strong&gt;,
&lt;/li&gt;
&lt;li&gt;
Assume all eigenvalues of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; are positive &lt;span class=&quot;math inline&quot;&gt;\(\lambda_\text{min}&amp;gt;0\)&lt;/span&gt;, which &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; provides the fastest rate of convergence?
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
  \rho(G) &amp;amp;= \max(|1-\omega \lambda_\text{min}|,|1-\omega \lambda_\text{max}|),\\
  \omega_\text{opt} &amp;amp;= 2/(\lambda_\text{max}+\lambda_\text{min}),\\
  \rho_\text{opt}(G) &amp;amp;= \frac{\lambda_\text{max}-\lambda_\text{min}}{\lambda_\text{max}+\lambda_\text{min}}.
  \end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;&lt;em&gt;Very slow convergence in presence of small and large eigenvalues.&lt;/em&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;jacobi-method&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Jacobi method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Choose &lt;span class=&quot;math inline&quot;&gt;\(M = \mathrm{diag}(A), K = M-A\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = M^{-1}(Kx^k+b)\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Requires nonzero diagonal entries, which can usually be accomplished by permuting rows and columns if not already true,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Requires duplicate storage for &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
Convergence rate may be very slow
&lt;ul&gt;
&lt;li&gt;
Does not always converge,
&lt;/li&gt;
&lt;li&gt;
Converges if matrix is strictly diagonally dominant.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;gauss-seidel-method&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Gauss-Seidel method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Jacobi method per element:
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1}_i = \frac{1}{a_{ii}}\Big(b_i-\sum_{j\ne i} a_{ij}x^k_j\Big).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We may get better convergence, if use the most recent value for &lt;span class=&quot;math inline&quot;&gt;\(x_j,\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In matrix form let &lt;span class=&quot;math inline&quot;&gt;\(A=L+U+D\)&lt;/span&gt; (strictly lower/upper triangular and diagonal):&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}M &amp;amp;= L+D, \qquad K = -U,\\
x^{k+1}_i &amp;amp;= (L+D)^{-1}(b-Ux^{k}) = -(L+D)^{-1} Ux^{k} + (L+D)^{-1}b.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Requires nonzero diagonal entries (may require row/column permutation),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Does not require duplicate storage for &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Does not always converge, it converges under conditions somewhat weaker than Jacobi,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Converges about twice as fast as Jacobi, but may still be very slow.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;sor-method&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;SOR method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Use the next Gauss-Seidel as search direction
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x^{k+1} = x^{k} + \omega \Big(x^{k+1}_{GS}-x^k \Big).\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; is a fixed &lt;em&gt;relaxation&lt;/em&gt; parameter
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(\omega&amp;gt;1\)&lt;/span&gt;: over-relaxation,
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(\omega&amp;lt;1\)&lt;/span&gt;: under-relaxation,
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(\omega=1\)&lt;/span&gt;: Gauss-Seidel,
&lt;/li&gt;
&lt;li&gt;
Choosing optimal &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; is difficult.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Converges much faster than Gauss-Seidel (with the optimal choice of &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;krylov-subspace-methods&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Krylov subspace methods&lt;/h1&gt;
&lt;section id=&quot;non-stationary-methods&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Non-stationary methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
How can we solve &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; if we only know &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; as black-box operator (can only do matvec)
&lt;ul&gt;
&lt;li&gt;
This happens often in practice,
&lt;/li&gt;
&lt;li&gt;
Matvec is the cheapest nontrivial matrix operation.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If matvec is all you can do, let’s keep multiplying&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{K}_m(A,v) = \Big\{ v, Av, A^2v, \dots, A^{m-1} v \Big\}. \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
What is the best approximation to the true solution &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; in &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_m,\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
If the residual is large, look for approximation in &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_{m+1}.\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
There are many different Krylov subspace methods (KSP)
&lt;ul&gt;
&lt;li&gt;
They have different assumptions about the matrix structure (symmetric, non-symmetric, etc.),
&lt;/li&gt;
&lt;li&gt;
Different rate of convergence.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;which-ksp&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Which KSP?&lt;/h2&gt;
&lt;p&gt;Consult “Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods”&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;assets/dedicated-hpc18/img/07-which-ksp.png&quot; alt=&quot;Which KSP&quot; class=&quot;center&quot; width=&quot;700&quot; /&gt;&lt;figcaption&gt;Which KSP&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;
&lt;section id=&quot;preliminaries&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Preliminaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Inner product for &lt;span class=&quot;math inline&quot;&gt;\(u,v\in \mathbb{R}^n\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v) = v^T u, \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Positive definite matrix
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (Au,u) &amp;gt; 0 \quad\text{for all}\quad x\ne 0,\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Condition number (SPD matrix)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\kappa(A) = \frac{|\lambda_\text{max}|}{|\lambda_\text{min}|},\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Weighted inner product for SPD matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v)_A = (u,Av) = v^TAu,\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Conjugate vectors with respect to SPD matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; (&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate)
&lt;ul&gt;
&lt;li&gt;
When &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; are orthogonal with respect to the inner product defined by &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (u,v)_A = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Suppose we have a set of &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; mutually &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate vectors&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(A) = \Big\{ p^i : (p^i,p^j)_A=0~\text{for}~i\ne j \Big\},\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(A)\)&lt;/span&gt; is a basis for &lt;span class=&quot;math inline&quot;&gt;\(R^n\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any vector, including the solution to the linear system &lt;span class=&quot;math inline&quot;&gt;\(x^\star\)&lt;/span&gt; can be represented in that basis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^\star = \sum_{i=1}^n \alpha_i p^i.\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;projection-method&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Projection method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Finding the solution to &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; is equivalent to finding &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;slide-pillars group&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
    Ax^\star &amp;amp;= b,\\
    \sum_i \alpha_i Ap^i &amp;amp;= b,\\
    \left(p^j, \sum_i \alpha_i Ap^i\right) &amp;amp;=\left(b,p^j\right),
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}
\sum_i \alpha_i \left(p^j,p^i\right)_A &amp;amp;=\left(b,p^j\right), \\
\alpha_j &amp;amp;= \frac{\left(b,p^j\right)}{\left(p^j,p^j\right)_A}.
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
Done only if we knew &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate vectors
&lt;ul&gt;
&lt;li&gt;
What is the cost of finding the solution in that case?
&lt;/li&gt;
&lt;li&gt;
Can we construct them?
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;conjugate-gradient&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Conjugate gradient&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
The solution to &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt; is the minimizer for this quadratic form
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(x) = (x,Ax) - (x,b) = \frac{1}{2} x^T A x - x^T b.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Why?
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla \phi(x) = \frac{1}{2} A x  + \frac{1}{2} A^T x - b  = Ax - b.\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;conjugate-gradient-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Conjugate gradient&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
For the initial guess &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt;, the steepest descent direction is &lt;span class=&quot;math inline&quot;&gt;\(-\nabla \phi(x^0)\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[-\nabla \phi(x^0) = b - Ax^0 = r^0, \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
This relationship is also true for any future descent direction:
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[-\nabla \phi(x^k) = b - Ax^k = r^k.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Let &lt;span class=&quot;math inline&quot;&gt;\(p^0 = r^0\)&lt;/span&gt; and construct a set of conjugate vectors iteratively using the descent direction.
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
Given &lt;span class=&quot;math inline&quot;&gt;\(r^k, (k=0,\dots,n)\)&lt;/span&gt;, compute the &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;th conjugate vector by Gram-Schmidt
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ p^k = r^k - \sum_{i&amp;lt;k} \frac{(r^k,p^k)_A}{(p^i,p^i)_A} p^i \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
The next solution candidate is
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x^{k+1} = x^k + \alpha_k p^k\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
We had a formula for the coefficient &lt;span class=&quot;math inline&quot;&gt;\(\alpha_k\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\alpha_k = \frac{\left(b,p^k\right)}{\left(p^k,p^k\right)_A} = \frac{\left(r^{k-1}+Ax^{k-1},p^k\right)}{\left(p^k,p^k\right)_A} = \frac{\left(r^{k-1},p^k\right)}{\left(p^k,p^k\right)_A}.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
The last simplification is because &lt;span class=&quot;math inline&quot;&gt;\(x^{k-1}\)&lt;/span&gt; is in the range of &lt;span class=&quot;math inline&quot;&gt;\(p^0,\dots,p^{k-1}\)&lt;/span&gt; that are &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;-conjugate to &lt;span class=&quot;math inline&quot;&gt;\(p^k\)&lt;/span&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;cg-features&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;CG Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Has a short recurrence
&lt;ul&gt;
&lt;li&gt;
Can compute the residual &lt;span class=&quot;math inline&quot;&gt;\(r^{k+1}\)&lt;/span&gt; from &lt;span class=&quot;math inline&quot;&gt;\(p^k,\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(p^{k+1}\)&lt;/span&gt; only requires &lt;span class=&quot;math inline&quot;&gt;\(r^{k+1},\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
Four vectors need to be stored &lt;span class=&quot;math inline&quot;&gt;\(x, p, r, Ap.\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It guarantees to converge in &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; step (in full precision)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Convergence rate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1 }. \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;what-if-the-matrix-is-not-spd&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;What if the matrix is not SPD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Minimize &lt;span class=&quot;math inline&quot;&gt;\(\|Ax -b\|^2\)&lt;/span&gt; over &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{K}_m(A, b)\)&lt;/span&gt;.
&lt;/li&gt;
&lt;li&gt;
Generalized Minimum RESidual (GMRES).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;preconditioning&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Preconditioning&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Convergence rate of KSP solvers depend on the condition number of the matrix
&lt;ul&gt;
&lt;li&gt;
Demo time (&lt;code&gt;Poisson&lt;/code&gt; python notebook)
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Instead of solving &lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;, if we use a matrix &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; such that &lt;span class=&quot;math inline&quot;&gt;\(\kappa(MA)&amp;lt;\kappa(A)\)&lt;/span&gt; we can improve the convergence rate
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;incremental&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ MAx = Mb. \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;span class=&quot;math inline&quot;&gt;\(M=A^{-1}\)&lt;/span&gt; is the perfect preconditioner
&lt;/li&gt;
&lt;li&gt;
The closer &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; is to &lt;span class=&quot;math inline&quot;&gt;\(A^{-1}\)&lt;/span&gt; the better
&lt;/li&gt;
&lt;li&gt;
Use approximate inverses of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;
Incomplete LU (ILU),
&lt;/li&gt;
&lt;li&gt;
Incomplete Cholesky (IC),
&lt;/li&gt;
&lt;li&gt;
Use knowledge of the problem.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;parallelization&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Parallelization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Required operations
&lt;ul&gt;
&lt;li&gt;
matvec,
&lt;/li&gt;
&lt;li&gt;
vector update (&lt;code&gt;axpy&lt;/code&gt;),
&lt;/li&gt;
&lt;li&gt;
inner product (reduction).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Need to decide how to partition data (the sparse matrix).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id=&quot;partitioning-for-iterative-solvers&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Partitioning for iterative solvers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Block partitioning of a sparse matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; is bad, some processors may not have any work,
&lt;/li&gt;
&lt;li&gt;
Row/column partitioning is better,
&lt;/li&gt;
&lt;li&gt;
Data locality can be achieved by,
&lt;ul&gt;
&lt;li&gt;
Partitioning graph of matrix,
&lt;/li&gt;
&lt;li&gt;
Partitioning underlying grid or mesh for finite difference or finite element problem.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;summary&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;section id=&quot;summary-1&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
Iterative methods for solving linear system &lt;span class=&quot;math inline&quot;&gt;\(Ax = b\)&lt;/span&gt; begin with initial guess for solution and successively improve it until solution is as accurate as desired.
&lt;/li&gt;
&lt;li&gt;
Iterations terminate when residual &lt;span class=&quot;math inline&quot;&gt;\(\|b-Ax\|\)&lt;/span&gt;, or some other measure of error, is as small as desired,
&lt;/li&gt;
&lt;li&gt;
Iterative methods are especially useful when matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; is sparse because, unlike direct methods, no fill-in is incurred.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 15 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-08-sparsela.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-08-sparsela.html</guid>
      
      
      <category>lecture</category>
      
    </item>
    
    <item>
      <title>MPI collectives</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Assignment 8 (credit: 60 points)&quot; /&gt;
  &lt;title&gt;MPI collectives&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;MPI collectives&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Assignment 8 (credit: 60 points)&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;Due: 10/30 11pm&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;introduction&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this lab session, we continue to study further new functionalities in MPI. We saw basic functions such as &lt;code&gt;MPI_Init&lt;/code&gt;, &lt;code&gt;MPI_Comm_rank&lt;/code&gt;, &lt;code&gt;MPI_Recv&lt;/code&gt;, &lt;code&gt;MPI_Send&lt;/code&gt;, etc. Today we will learn about more collectives, variable-size collectives and sparse matrices.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;basic-mpi-collectives&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Basic MPI Collectives&lt;/h1&gt;
&lt;p&gt;If all processes have individual data, for instance the result of a local computation, you may want to bring that information together, for instance to find the maximum array value from last week task or the sum of all values. Conversely, sometimes one processor has information that needs to be shared with all. For these sort of operations, MPI has collectives. Following are the few most common collectives used in MPI.&lt;/p&gt;
&lt;section id=&quot;mpi_scatter&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Scatter&lt;/h2&gt;
&lt;p&gt;In many parallel programs, we want each process to work on a subset of the data (e.g., an array). We could accomplish this by dividing the data into chunks, and sending each chunk to one of the processes. &lt;code&gt;MPI_Scatter&lt;/code&gt; is just the function for this&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Scatter(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;* sendbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sendcount, MPI_Datatype sendtype,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;            &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;* recvbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recvcount, MPI_Datatype recvtype,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root, MPI_Comm comm);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The root process sends data while the others receive data. Note that &lt;code&gt;sendcount&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;number of elements sent to each process&lt;/em&gt;&lt;/strong&gt; and not the size of sendbuf. MPI divides the data between everyone, including the sender.&lt;/p&gt;
&lt;div class=&quot;emphbox&quot;&gt;
&lt;p&gt;Note that since MPI is designed for SPMD programming, all processors call the same &lt;code&gt;MPI_scatter&lt;/code&gt; (or other collective function) with the same signature. In scatter, only the root processor need to allocate &lt;code&gt;sendbuf&lt;/code&gt; and set &lt;code&gt;sendcount&lt;/code&gt; to a correct number.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi_gather&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Gather&lt;/h2&gt;
&lt;p&gt;The dual operator for scatter is gather, where portions of data from processors are collected into one array in one process. This can be done with &lt;code&gt;MPI_Gather&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Gather(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *sendbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sendcount, MPI_Datatype sendtype,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;               &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *recvbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recvcount, MPI_Datatype recvtype,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;               &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root, MPI_Comm comm)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function takes exactly the same parameters as &lt;code&gt;MPI_Scatter&lt;/code&gt;, but goes in the opposite direction and gathers the data in the &lt;code&gt;recvbuf&lt;/code&gt; of the root. Similar to scatter, &lt;code&gt;recvcount&lt;/code&gt; is the number of elements for any single receive. The size of &lt;code&gt;recvbuf&lt;/code&gt; should be &lt;code&gt;recvcount&lt;/code&gt; times the number of processors.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi_reduce&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Reduce&lt;/h2&gt;
&lt;p&gt;The global sum problem is an example of a reduction problem. We want to apply some operation across a set of data, and collect the result as one value. &lt;code&gt;MPI_Reduce&lt;/code&gt; is a collective communication function. It is used to specify that some communication should happen amongst all processes. The function looks like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Reduce( &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *sendbuf, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *recvbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;                MPI_Datatype datatype, MPI_Op op, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;                MPI_Comm comm)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember the &lt;code&gt;recvbuf&lt;/code&gt; is only used by the root process, but we still must pass an argument for each process.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi_bcast&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Bcast&lt;/h2&gt;
&lt;p&gt;If we want to simply send a value from one process to all other processes, we can do that efficiently with a broadcast operation. This is done with the MPI_Bcast function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Bcast( &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *sendbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count, MPI_Datatype datatype, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-2&quot; data-line-number=&quot;2&quot;&gt;               MPI_Comm comm )&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A common usage of &lt;code&gt;MPI_Bcast&lt;/code&gt; is sending input values to all processes.&lt;/p&gt;
&lt;p&gt;The following are some other collective operations that combine the basic operations we outlined above:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;MPI_Allreduce&lt;/code&gt;: It’s equivalent to a &lt;code&gt;MPI_Reduce&lt;/code&gt; followed by a broadcast.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MPI_Allgather&lt;/code&gt;: It’s equivalent to a &lt;code&gt;MPI_Gather&lt;/code&gt; followed by a broadcast.&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi-variable-size-collectives&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;MPI variable-size Collectives&lt;/h1&gt;
&lt;p&gt;In the above MPI Collectives, such as &lt;code&gt;MPI_Gather&lt;/code&gt; and &lt;code&gt;MPI_Scatter&lt;/code&gt; each processor received or sent an identical number of items. In many cases this is appropriate, but sometimes each processor wants or contributes a specific number of items which can be different from other processors. To accommodate that, MPI has variable-message-size versions for these collective methods.&lt;/p&gt;
&lt;section id=&quot;mpi_gatherv&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Gatherv&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MPI_Gatherv&lt;/code&gt; extends the functionality of &lt;code&gt;MPI_Gather&lt;/code&gt; to permit a varying count of data from each process, and to allow some flexibility in where the gathered data is placed on the root process. It does this by changing the count argument from a single integer to an integer array.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Gatherv(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *sendbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sendcount, MPI_Datatype sendtype,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-2&quot; data-line-number=&quot;2&quot;&gt;                &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *recvbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recvcounts[], &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset[],&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-3&quot; data-line-number=&quot;3&quot;&gt;                MPI_Datatype recvtype, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root, MPI_Comm comm)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;recvcounts&lt;/code&gt; is a non-negative integer array containing the number of elements that are received from each process (significant only at root) and &lt;code&gt;offset&lt;/code&gt; is an integer array (of length group size) where element at index &lt;code&gt;i&lt;/code&gt; specifies the displacement relative to &lt;code&gt;recvbuf&lt;/code&gt; at which, to place the incoming data from process &lt;code&gt;i&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;emphbox&quot;&gt;
&lt;p&gt;It the responsibility of the receiver to allocate enough memory for all data and set the right offset for the incoming data from each processor to avoid overwrite.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;It is typical to call &lt;code&gt;MPI_Gather&lt;/code&gt; before &lt;code&gt;MPI_Gatherv&lt;/code&gt;, to communicate the message size form each processor to determine the receive buffer size and the proper offset. For example,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rank, nproc;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-2&quot; data-line-number=&quot;2&quot;&gt;MPI_Comm_rank(MPI_COMM_WORLD,&amp;amp;rank);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-3&quot; data-line-number=&quot;3&quot;&gt;MPI_Comm_size(MPI_COMM_WORLD,&amp;amp;nproc);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; local_size(rank&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *local_data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[local_size];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ii=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;ii&amp;lt;local_size;++ii) local_data[ii]=rank;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-8&quot; data-line-number=&quot;8&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bufsz;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-10&quot; data-line-number=&quot;10&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *all_data(NULL);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-11&quot; data-line-number=&quot;11&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-12&quot; data-line-number=&quot;12&quot;&gt;&lt;span class=&quot;co&quot;&gt;// the root process first aggregates the size of incoming date&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-13&quot; data-line-number=&quot;13&quot;&gt;&lt;span class=&quot;co&quot;&gt;// create arrays to contain size and offset information&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-14&quot; data-line-number=&quot;14&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *local_sizes(NULL), *offsets(NULL);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-15&quot; data-line-number=&quot;15&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (rank == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-16&quot; data-line-number=&quot;16&quot;&gt;    local_sizes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[nproc];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-17&quot; data-line-number=&quot;17&quot;&gt;    offsets     = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[nproc];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-18&quot; data-line-number=&quot;18&quot;&gt;}&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-19&quot; data-line-number=&quot;19&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-20&quot; data-line-number=&quot;20&quot;&gt;&lt;span class=&quot;co&quot;&gt;// each process contributes its info&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-21&quot; data-line-number=&quot;21&quot;&gt;MPI_Gather(&amp;amp;local_size, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, MPI_INT, local_sizes,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, MPI_INT, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, MPI_COMM_WORLD);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-22&quot; data-line-number=&quot;22&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-23&quot; data-line-number=&quot;23&quot;&gt;&lt;span class=&quot;co&quot;&gt;// the root constructs the offsets array to receive data&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-24&quot; data-line-number=&quot;24&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (rank == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-25&quot; data-line-number=&quot;25&quot;&gt;    offsets[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-26&quot; data-line-number=&quot;26&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ii=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; ii&amp;lt;nproc; ++ii)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-27&quot; data-line-number=&quot;27&quot;&gt;        offsets[ii] = offsets[ii&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;]+local_sizes[ii&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-28&quot; data-line-number=&quot;28&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-29&quot; data-line-number=&quot;29&quot;&gt;    bufsz    = offsets[nproc&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;]+local_sizes[nproc&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-30&quot; data-line-number=&quot;30&quot;&gt;    all_data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[bufsz];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-31&quot; data-line-number=&quot;31&quot;&gt;}&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-32&quot; data-line-number=&quot;32&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-33&quot; data-line-number=&quot;33&quot;&gt;&lt;span class=&quot;co&quot;&gt;// final gather&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-34&quot; data-line-number=&quot;34&quot;&gt; MPI_Gatherv(local_data,local_size, MPI_INT,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-35&quot; data-line-number=&quot;35&quot;&gt;             all_data,local_sizes,offsets,MPI_INT, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, MPI_COMM_WORLD);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-36&quot; data-line-number=&quot;36&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-37&quot; data-line-number=&quot;37&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (rank == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-38&quot; data-line-number=&quot;38&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ii=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; ii&amp;lt;bufsz; ++ii)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-39&quot; data-line-number=&quot;39&quot;&gt;        printf(&lt;span class=&quot;st&quot;&gt;&amp;quot;data[&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;,ii,all_data[ii]);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-40&quot; data-line-number=&quot;40&quot;&gt;}&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-41&quot; data-line-number=&quot;41&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-42&quot; data-line-number=&quot;42&quot;&gt;&lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt;[] local_sizes;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-43&quot; data-line-number=&quot;43&quot;&gt;&lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt;[] offsets;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-44&quot; data-line-number=&quot;44&quot;&gt;&lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt;[] all_data;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is &lt;code&gt;MPI_Allgatherv&lt;/code&gt; collective which is equivalent to an &lt;code&gt;MPI_Gatherv&lt;/code&gt; followed by a broadcast.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi_scatterv&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI_Scatterv&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MPI_Scatterv&lt;/code&gt; extends &lt;code&gt;MPI_Scatter&lt;/code&gt; in a similar manner. It scatters a buffer in parts to all processes in a communicator.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MPI_Scatterv(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;* sendbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sendcounts[], &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset[],&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-2&quot; data-line-number=&quot;2&quot;&gt;                 MPI_Datatype sendtype, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;* recvbuf, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recvcount,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-3&quot; data-line-number=&quot;3&quot;&gt;                 MPI_Datatype recvtype, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; root, MPI_Comm comm)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi-all-to-all&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;MPI All to All&lt;/h2&gt;
&lt;p&gt;The all-to-all call is a generalization of a scatter and a gather. Every process is scattering an array of data, and every process is gathering an array of data. It can also be seen as an extension of &lt;code&gt;MPI_Allgather&lt;/code&gt; to the case where each process sends distinct data to each receiver. There is also a &lt;code&gt;v&lt;/code&gt; variant of this routine.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MPI_Alltoall&lt;/code&gt; is very useful in applications like matrix transposes or Fast Fourier Transforms (FFTs), etc.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;sparse-matrices&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Sparse matrices&lt;/h1&gt;
&lt;p&gt;A matrix in which most of the elements are zero, is referred as &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;Sparse matrix&lt;/a&gt;. Operations and algorithms used for standard matrix structures are inefficient and slow when applied to large sparse matrices as processing and memory are wasted on the zeroes. Therefore, It is beneficial and often necessary to use specialized algorithms that take advantage of the sparse structure of the matrix. Sparse data is by nature more easily compressed and thus require significantly less storage.&lt;/p&gt;
&lt;section id=&quot;compressed-sparse-row-csr&quot; class=&quot;level2&quot;&gt;
&lt;h2&gt;Compressed sparse row (CSR)&lt;/h2&gt;
&lt;p&gt;The compressed sparse row format represents a sparse &lt;span class=&quot;math inline&quot;&gt;\(m \times n\)&lt;/span&gt; matrix &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; by three (one-dimensional) arrays, that respectively contain nonzero values of &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;, their column indices and the row pointers. Letting &lt;span class=&quot;math inline&quot;&gt;\(N_z\)&lt;/span&gt; denote the total number of nonzero elements in &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;data&lt;/code&gt; is of length &lt;span class=&quot;math inline&quot;&gt;\(N_z\)&lt;/span&gt; and holds all the nonzero entries of &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; in a row-major fashion.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;column&lt;/code&gt; contains the column index in &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; of the corresponding element of &lt;code&gt;data&lt;/code&gt; and is of length &lt;span class=&quot;math inline&quot;&gt;\(N_z\)&lt;/span&gt; as well.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;row_ptr&lt;/code&gt; is of length &lt;span class=&quot;math inline&quot;&gt;\(m+1\)&lt;/span&gt;. Element &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; has the index for the start of row &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; in the other two arrays. The last element is &lt;code&gt;row_ptr[0]&lt;/code&gt;&lt;span class=&quot;math inline&quot;&gt;\(+N_z\)&lt;/span&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, the matrix&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[M = \begin{bmatrix}
a &amp;amp; 0 &amp;amp; b &amp;amp; 0 \\
0 &amp;amp; c &amp;amp; 0 &amp;amp; d \\
0 &amp;amp; 0 &amp;amp; e &amp;amp; 0 \\
f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;can be stored as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;data&lt;/code&gt; = [ a, b, c, d, e, f ]
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;column&lt;/code&gt; = [ 0, 2, 1, 3, 2, 0 ]
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;row_ptr&lt;/code&gt; = [ 0, 2, 4, 5, 6 ]
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;task&quot;&gt;
&lt;h3&gt;Task 1&lt;/h3&gt;
&lt;p&gt;Given a sparse &lt;span class=&quot;math inline&quot;&gt;\(m\times n\)&lt;/span&gt; matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; that is stored row-wise among &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; processors, we would like to compute its transpose &lt;span class=&quot;math inline&quot;&gt;\(B=A^T\)&lt;/span&gt;. Matrix &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; is also expected to be in CSR format and distributed row-wise (similar to &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Each processor owns &lt;span class=&quot;math inline&quot;&gt;\(m/p\)&lt;/span&gt; rows of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(n/p\)&lt;/span&gt; rows of &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;. On each processor, the three CSR arrays for &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; correspond to the &lt;span class=&quot;math inline&quot;&gt;\((m/p)\times n\)&lt;/span&gt; submatrix owned by that processor. To get the row index of an element in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;, the row number from local CSR should be offset by &lt;span class=&quot;math inline&quot;&gt;\(rm/p\)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; is the processor rank.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You need to use some of the MPI collective operators that we discussed today to perform this task.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It may be easier to use an intermediate storage scheme, such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;coordinate format&lt;/a&gt;, for transposing. The bookkeeping is easier if you follow these steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
Put the local submatrix in coordinate format.
&lt;/li&gt;
&lt;li&gt;
Locally compute the transpose of the submatrix in coordinate. format, at this stage each processor holds &lt;span class=&quot;math inline&quot;&gt;\(n\times m/p\)&lt;/span&gt; column submatrix of &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;.
&lt;/li&gt;
&lt;li&gt;
Use MPI collectives to communicate the rows to the destination processor. After this, each processor holds the correct &lt;span class=&quot;math inline&quot;&gt;\(n/p\times m\)&lt;/span&gt; submatrix of &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;..
&lt;/li&gt;
&lt;li&gt;
Put the local submatrix back in CSR format.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are providing the following (base) class for storing local matrices and a utility function &lt;code&gt;sort_index&lt;/code&gt;, which may be useful when switching between CSR and coordinate formats. In coordinate format, elements may be ordered arbitrarily in contrast to CSR where elements are ordered in a row-major fashion. You need to pass &lt;code&gt;-std=c++11&lt;/code&gt; flag to the compiler for this code.&lt;/p&gt;
&lt;p&gt;Apart from transpose, you can add/implement any other function that you need in &lt;code&gt;sparse&lt;/code&gt; class.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode numberSource cpp numberLines&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;pp&quot;&gt;#include &lt;/span&gt;&lt;span class=&quot;im&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;data_t&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;co&quot;&gt; *  Returns the shuffling index set such that v[idx] is sorted&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sort_index(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt;&amp;gt; &amp;amp;v, &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt;&amp;gt; &amp;amp;idx){&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-9&quot; data-line-number=&quot;9&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-10&quot; data-line-number=&quot;10&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; n(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-11&quot; data-line-number=&quot;11&quot;&gt;    idx.resize(v.size());&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-12&quot; data-line-number=&quot;12&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;generate(idx.begin(), idx.end(), [&amp;amp;]{ &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; n++; });&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-13&quot; data-line-number=&quot;13&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;sort(idx.begin(), idx.end(), &lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-14&quot; data-line-number=&quot;14&quot;&gt;              [&amp;amp;](&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; ii, &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; jj) { &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; v[ii] &amp;lt; v[jj]; } );&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-15&quot; data-line-number=&quot;15&quot;&gt;}&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-16&quot; data-line-number=&quot;16&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-17&quot; data-line-number=&quot;17&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; sparse {&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-18&quot; data-line-number=&quot;18&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-19&quot; data-line-number=&quot;19&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;storage_type&lt;/span&gt; {CSR, COO};&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-20&quot; data-line-number=&quot;20&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;data_t&lt;/span&gt;&amp;gt; data;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-21&quot; data-line-number=&quot;21&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt;&amp;gt; column;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-22&quot; data-line-number=&quot;22&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt;&amp;gt; row;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-23&quot; data-line-number=&quot;23&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-24&quot; data-line-number=&quot;24&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; m,n; &lt;span class=&quot;co&quot;&gt;/* (local) matrix dimensions */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-25&quot; data-line-number=&quot;25&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;storage_type&lt;/span&gt; type;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-26&quot; data-line-number=&quot;26&quot;&gt;    sparse(&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;storage_type&lt;/span&gt; t = CSR);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-27&quot; data-line-number=&quot;27&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; transpose(sparse &amp;amp;B) &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* returns transpose in B */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-28&quot; data-line-number=&quot;28&quot;&gt;};&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-29&quot; data-line-number=&quot;29&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-30&quot; data-line-number=&quot;30&quot;&gt;sparse::sparse(&lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;storage_type&lt;/span&gt; t) :&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-31&quot; data-line-number=&quot;31&quot;&gt;    m(m), n(n), type(t) {}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Mon, 15 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-08-lab-mpi.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-08-lab-mpi.html</guid>
      
      
      <category>assignment</category>
      
    </item>
    
    <item>
      <title>MPI topologies</title>
      <description>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Assignment 7 (credit: 65 points + 20 bonus)&quot; /&gt;
  &lt;title&gt;MPI topologies&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/tufte.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar-print.css&quot; media=&quot;print&quot; type=&quot;text/css&quot; /&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;group&quot; id=&quot;header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;MPI topologies&lt;/h1&gt;
&lt;h2 class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/h1&gt;
&lt;h2 class=&quot;author&quot;&gt;Assignment 7 (credit: 65 points + 20 bonus)&lt;/h2&gt;
&lt;h3 class=&quot;date&quot;&gt;Due: 10/23 11pm&lt;/h3&gt;
&lt;/div&gt;
&lt;section id=&quot;elliptic-partial-differential-equations&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Elliptic Partial Differential Equations&lt;/h1&gt;
&lt;p&gt;One of the most fundamental partial differential equation (PDE) in mathematical physics is the Poisson’s equation&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} a(x)u(x)-\Delta u(x)&amp;amp;=f(x), \quad\text{for}\quad x \in
B,\label{eq-poisson}\\ u(x)&amp;amp;=0, \quad\text{for}\quad x \in \partial
B\label{eq-bc}, \end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt; denotes the Laplacian operator; &lt;span class=&quot;math inline&quot;&gt;\(a(x)\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; are known functions. Here we assume that the domain &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; is the unit cube in 3D &lt;span class=&quot;math inline&quot;&gt;\([0,1]^3\)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;\(\partial B\)&lt;/span&gt; denotes the boundary of the domain &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; (the faces of the unit cube). This is an example of a boundary value problem. We can express the problem more compactly as&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation}L(x) u(x) = f(x),\label{eq:main-abstract}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; is a linear differential operator.&lt;/p&gt;
&lt;p&gt;We can discretize the PDE using finite differences. For &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; discretization point along each axis, let &lt;span class=&quot;math inline&quot;&gt;\(h=1/(n-1)\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(x_{i,j,k} = (ih,jh,kh)\)&lt;/span&gt; for &lt;span class=&quot;math inline&quot;&gt;\(0\le i,j,k &amp;lt; n\)&lt;/span&gt;. Let &lt;span class=&quot;math inline&quot;&gt;\(a_{i,j,k} = a(x_{i,j,k})\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(f_{i,j,k} = f(x_{i,j,k})\)&lt;/span&gt;, and &lt;span class=&quot;math inline&quot;&gt;\(u_{i,j,k} = u(x_{i,j,k})\)&lt;/span&gt;. Estimating the Laplacian at interior points using a seven-point central difference we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}(\Delta_h u_h)_{i,j,k} &amp;amp;= \frac{u_{i + 1,j,k} +
u_{i-1,j,k} + u_{i,j + 1,k} + u_{i,j-1,k} + u_{i,j,k + 1} + 
u_{i,j,k-1} -6 u_{i,j,k}}{h^2},\label{eq-lap-disc}\\ (L_h u_h)_{i,j,k}
&amp;amp;= a_{i,j,k} u_{i,j,k} - (\Delta_h
u_h)_{i,j,k},\label{eq-disc}\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;for &lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;i,j,k&amp;lt;n-1\)&lt;/span&gt;. The boundary condition, Eq. \eqref{eq-bc}, implies that &lt;span class=&quot;math display&quot;&gt;\[ u_{0,j,k} = u_{n-1,j,k} = u_{i,0,k} = u_{i,n-1,k} = u_{i,j,0}
= u_{i,j,n-1} = 0, \quad\text{for all}\quad i,j,k.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here, we used the subscript &lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt; to denote discretized variables or operators. This discretization casts Eq. \eqref{eq:main-abstract} to&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L_h u_h = f_h.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If &lt;span class=&quot;math inline&quot;&gt;\(v_h\)&lt;/span&gt; is a solution candidate, we define its residual as&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[r_h = f_h - L_h v_h, \quad r = \left(\sum_{ijk}
r_h^2(x_{ijk})\right)^{1/2}.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that, the residual &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; is zero for the solution of the PDE.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;mpi-virtual-topology&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;MPI virtual topology&lt;/h1&gt;
&lt;p&gt;To facilitate the mapping of computational domains to MPI processors, MPI provides ways of creating virtual topologies. To solve the Poisson’s equation in the domain &lt;span class=&quot;math inline&quot;&gt;\(B=[0,1]^3\)&lt;/span&gt;, we would like to partition the domain to a 3D grid and assign each grid box to a processors.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MPI_Cart_create&lt;/code&gt; creates a new MPI communicator with 2D or 3D grid topology. This will greatly simplify the communication pattern of our Poisson solver by making it much easier to find processors holding neighboring grid boxes.&lt;/p&gt;
&lt;p&gt;Other MPI functions that are useful for a grid topology are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;MPI_Dims_create&lt;/code&gt; creates a division of processors in a Cartesian grid. This generates the &lt;code&gt;dims&lt;/code&gt; argument to &lt;code&gt;MPI_Cart_create&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;MPI_Cart_coords&lt;/code&gt; return the coordinates of a processor in a Cartesian topology given its rank.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;MPI_Cart_rank&lt;/code&gt; determines the rank of a process in a communicator given its Cartesian location.
&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;MPI_Cart_shift&lt;/code&gt; returns the rank of the processes shifted up or down in the direction specified. Shifts of &lt;span class=&quot;math inline&quot;&gt;\(+1\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; and dimensions &lt;span class=&quot;math inline&quot;&gt;\(0,1,2\)&lt;/span&gt; give all six neighbors of a processor. This may return &lt;code&gt;MPI_PROC_NULL&lt;/code&gt; when the requested neighbor does not exist, e.g., when the processor is on the corner of a grid.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consult the &lt;a href=&quot;https://www.mpich.org/static/docs/latest/&quot;&gt;MPI documentation&lt;/a&gt; for more detail about these functions.&lt;/p&gt;
&lt;p&gt;After constructing the grid communicator, to send and receive messages, you need to use these functions to decide the rank of the receiver/sender.&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;computing-the-residual&quot; class=&quot;level1&quot;&gt;
&lt;h1&gt;Computing the residual&lt;/h1&gt;
&lt;p&gt;Our objective is to write a solver for the Poisson’s equation. Today, we only focus on the task of evaluating the residual for a candidate solution. In a later assignment, we will extend this code to build the solver.&lt;/p&gt;
&lt;p&gt;Write three functions with the following signatures that set up the Poisson grid, do the matvec, and compute the residual. The function definitions are in &lt;code&gt;w07/poisson.h&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource cpp numberLines&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;kw&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;point_t&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;{&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; coord[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;];&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-6&quot; data-line-number=&quot;6&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-7&quot; data-line-number=&quot;7&quot;&gt;        &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; x;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-8&quot; data-line-number=&quot;8&quot;&gt;        &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; y;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-9&quot; data-line-number=&quot;9&quot;&gt;        &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; z;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-10&quot; data-line-number=&quot;10&quot;&gt;    };&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-11&quot; data-line-number=&quot;11&quot;&gt;};&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-12&quot; data-line-number=&quot;12&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-13&quot; data-line-number=&quot;13&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt;&amp;gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-14&quot; data-line-number=&quot;14&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;vector&amp;lt;&lt;span class=&quot;dt&quot;&gt;point_t&lt;/span&gt;&amp;gt; &lt;span class=&quot;dt&quot;&gt;grid_t&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-15&quot; data-line-number=&quot;15&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-16&quot; data-line-number=&quot;16&quot;&gt;&lt;span class=&quot;co&quot;&gt;// define a type for matvec with vector input and output&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-17&quot; data-line-number=&quot;17&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;std::&lt;/span&gt;function&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;, &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;)&amp;gt; &lt;span class=&quot;dt&quot;&gt;matvec_t&lt;/span&gt;;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-18&quot; data-line-number=&quot;18&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-19&quot; data-line-number=&quot;19&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-20&quot; data-line-number=&quot;20&quot;&gt;&lt;span class=&quot;co&quot;&gt; * Set up the grid communicator for the Poisson problem and samples&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-21&quot; data-line-number=&quot;21&quot;&gt;&lt;span class=&quot;co&quot;&gt; * the correct portion of the domain&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-22&quot; data-line-number=&quot;22&quot;&gt;&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-23&quot; data-line-number=&quot;23&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @comm input communicator, typically MPI_COMM_WORLD&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-24&quot; data-line-number=&quot;24&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @n problem size, there are n sample points along each axis&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-25&quot; data-line-number=&quot;25&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @grid_comm the grid communicator (output)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-26&quot; data-line-number=&quot;26&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @x sample points assigned to the current MPI process based on its grid coordinates (output)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-27&quot; data-line-number=&quot;27&quot;&gt;&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-28&quot; data-line-number=&quot;28&quot;&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-29&quot; data-line-number=&quot;29&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; poisson_setup(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; MPI_Comm &amp;amp;comm, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, MPI_Comm &amp;amp;grid_comm, &lt;span class=&quot;dt&quot;&gt;grid_t&lt;/span&gt; &amp;amp;x);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-30&quot; data-line-number=&quot;30&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-31&quot; data-line-number=&quot;31&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-32&quot; data-line-number=&quot;32&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @grid_comm grid communicator returned by poisson_setup&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-33&quot; data-line-number=&quot;33&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @a value of coefficient a at points x&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-34&quot; data-line-number=&quot;34&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @v candidate solution at points x&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-35&quot; data-line-number=&quot;35&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @lv the matrix-vector product of the discrete Poisson&amp;#39;s operator&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-36&quot; data-line-number=&quot;36&quot;&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-37&quot; data-line-number=&quot;37&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; poisson_matvec(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; MPI_Comm &amp;amp;grid_comm, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;a, &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;v, &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;lv);&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-38&quot; data-line-number=&quot;38&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-39&quot; data-line-number=&quot;39&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-40&quot; data-line-number=&quot;40&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @comm mpi communicator&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-41&quot; data-line-number=&quot;41&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @mv the matvec operator&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-42&quot; data-line-number=&quot;42&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @v the input vector to matvec&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-43&quot; data-line-number=&quot;43&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @rhs the right-hand-side of the linear operator&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-44&quot; data-line-number=&quot;44&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @res the point-wise residual (output)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-45&quot; data-line-number=&quot;45&quot;&gt;&lt;span class=&quot;co&quot;&gt; * @res_norm the L2 norm of the residual vector `res`&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-46&quot; data-line-number=&quot;46&quot;&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-47&quot; data-line-number=&quot;47&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; residual(&lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; MPI_Comm &amp;amp;comm, &lt;span class=&quot;dt&quot;&gt;matvec_t&lt;/span&gt; &amp;amp;mv, &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;v, &lt;span class=&quot;at&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;rhs,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-48&quot; data-line-number=&quot;48&quot;&gt;              &lt;span class=&quot;dt&quot;&gt;vec_t&lt;/span&gt; &amp;amp;res, &lt;span class=&quot;dt&quot;&gt;real_t&lt;/span&gt; &amp;amp;res_norm);&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The scaffolding of the test driver is in &lt;code&gt;w07/test_poisson.h&lt;/code&gt;, you need to complete that for testing. All MPI processes assign the value of the pointwise residual to &lt;code&gt;res&lt;/code&gt; and the residual norm to &lt;code&gt;res_norm&lt;/code&gt; and return. Here are some comments to help you write these functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
You have to use &lt;code&gt;MPI_Cart_create&lt;/code&gt; to create a virtual 3D grid network topology for easier communication. &lt;code&gt;poisson_setup&lt;/code&gt; returns the newly created communicator along with sample points in the region assigned to that processor. &lt;code&gt;MPI_Dims_create&lt;/code&gt; and &lt;code&gt;MPI_Cart_coords&lt;/code&gt; are useful functions that you may use inside &lt;code&gt;poisson_setup&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
Each processor in the grid topology has a linear rank and a Cartesian coordinate. You should use the Cartesian coordinate of the processor to decide which points to sample.
&lt;/li&gt;
&lt;li&gt;
Assume we have &lt;span class=&quot;math inline&quot;&gt;\(p=k^3\)&lt;/span&gt; processors and let &lt;span class=&quot;math inline&quot;&gt;\(m=n/k\)&lt;/span&gt;, then processor &lt;span class=&quot;math inline&quot;&gt;\(P_{abc}\)&lt;/span&gt; has points with index &lt;span class=&quot;math inline&quot;&gt;\((am+i,bm+j,cm+k)\)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;\(0\le i,j,k &amp;lt; m, 0\le a,b,c&amp;lt;k\)&lt;/span&gt;. Extending to the case where the number of processors is not a perfect cube is straightforward using &lt;code&gt;MPI_Dims_create&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To compute &lt;span class=&quot;math inline&quot;&gt;\(r_h\)&lt;/span&gt; at a point where the finite difference stencil has nodes outside the current processor, you need to communicate the value of &lt;span class=&quot;math inline&quot;&gt;\(v_h\)&lt;/span&gt; from neighboring processors. Almost all processors communicate with their six neighbors and exchange data. Some only have five, four, or three neighbors and &lt;code&gt;MPI_Cart_shift&lt;/code&gt; returns &lt;code&gt;MPI_PROC_NULL&lt;/code&gt; when you try to get the rank of missing neighbors.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;After computing the point-wise residual, you need to do an all-to-all reduce to compute the final answer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Order the send and receive calls so that you do not create a deadlock.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;task&quot;&gt;
&lt;h3&gt;Task 1&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Submit your implementation for these three functions in &lt;code&gt;w07/possion.cc&lt;/code&gt;. Do not assume that the number of processors &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; is a perfect cube. However, you can safely assume that &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; is divisible by factors of &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; (returned by &lt;code&gt;MPI_Dims_create&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check the correctness of your algorithm by using known solutions of Poisson’s equations. Report the residual norm with respect to &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;, the residual norm &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; should decrease as you increase &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;. Use&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}
 a &amp;amp;= 12,\\
 u &amp;amp;= \sin(4\pi x) \sin(10\pi y) \sin(14\pi z),\\
 f &amp;amp;= \sin(4\pi x)\sin(10\pi y)\sin(14\pi z)(12+312\pi^2).
 \end{align}\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Perform strong scaling analysis on &lt;code&gt;poisson_residual&lt;/code&gt; function on Summit. Use &lt;span class=&quot;math inline&quot;&gt;\(n=240\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(p=1,8,27\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(p=1,4,9,16,25\)&lt;/span&gt;. Report wall-clock-time and speedup vs. number of processors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Perform weak scaling analysis on &lt;code&gt;poisson_residual&lt;/code&gt; function on Summit. Fix &lt;span class=&quot;math inline&quot;&gt;\(n^3/p\)&lt;/span&gt; to be &lt;span class=&quot;math inline&quot;&gt;\(27M\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(p=8,27,64\)&lt;/span&gt;. Report wall-clock-time vs. number of processors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[bonus] Use non-blocking communication combined with overlapping communication and computation to further speed up your code. Repeat the strong scaling test.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Thu, 04 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-07-lab-topology.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-07-lab-topology.html</guid>
      
      
      <category>assignment</category>
      
    </item>
    
    <item>
      <title>Dense matrix factorization (LU, Cholesky, QR)</title>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot;&gt;
  &lt;meta name=&quot;author&quot; content=&quot;Abtin Rahimian&quot;&gt;
  &lt;meta name=&quot;dcterms.date&quot; content=&quot;2017-10-04&quot;&gt;
  &lt;base href=&quot;../../&quot;&gt;
  &lt;title&gt;Dense matrix factorization (LU, Cholesky, QR)&lt;/title&gt;
  &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/reveal.css&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/js/reveal.js/css/theme/white.css&quot; id=&quot;theme&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/ar.css&quot;/&gt;
  &lt;!-- Printing and PDF exports --&gt;
  &lt;script&gt;
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'assets/js/reveal.js/css/print/pdf.css' : 'assets/js/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  &lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
  &lt;script src=&quot;assets/js/reveal.js/lib/js/html5shiv.js&quot;&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
  &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    TeX: {
        Macros: {
  	  itxt: [&quot;\\quad\\text{#1}\\quad&quot;, 1],
  	  set: [&quot;\left\{#1\right\}&quot;, 1],
  	  sci: [&quot;\\times 10^{#1}&quot;,1],
  	  ip:  [&quot;\\left\\langle #1, #2 \\right\\rangle&quot;,2],
  	  norm:  [&quot;\\left\\| #1 \\right\\|&quot;,1],
  	  vector: [&quot;\\mathbf{#1}&quot;,1],
  	  pop: [&quot;\\mathbb{#1}&quot;, 1],
  	  Exp: [&quot;\\mathbb{E}&quot;],
  	  disc: [&quot;\\mathsf{#1}&quot;,1],
        },
        equationNumbers: {autoNumber: &quot;AMS&quot;}
    }
  });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;reveal&quot;&gt;
    &lt;div class=&quot;slides&quot;&gt;

&lt;section&gt;
  &lt;h1 class=&quot;title&quot;&gt;Dense matrix factorization (LU, Cholesky, QR)&lt;/h1&gt;
  &lt;p class=&quot;subtitle&quot;&gt;High-Performance Scientific Computing (CSCI 4576/5576)&lt;/p&gt;
  &lt;p class=&quot;author&quot;&gt;Abtin Rahimian&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;October 4, 2017&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;&lt;section id=&quot;review&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Review&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;matrix-operations&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Matrix operations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Inner product
&lt;ul&gt;
&lt;li&gt;All-to-all reduce: &lt;span class=&quot;math inline&quot;&gt;\(O(p-1), O(\sqrt{p}-1)\)&lt;/span&gt;, or &lt;span class=&quot;math inline&quot;&gt;\(O(\log p)\)&lt;/span&gt; depending on network.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Outer product &lt;span class=&quot;math inline&quot;&gt;\(A=x y^T\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;Row block: all-to-all broadcast of &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;2D grid: broadcast segments of &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;/&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; along processor row/column (no need to do all-to-all).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Matrix-vector product (matvec &lt;span class=&quot;math inline&quot;&gt;\(y=y+Ax\)&lt;/span&gt;)
&lt;ul&gt;
&lt;li&gt;1D row: all-to-all broadcast &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;1D column: reduce &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;2D grid: broadcast &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; segment along columns, reduce &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; along rows.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Matrix-matrix product (matmul &lt;span class=&quot;math inline&quot;&gt;\(C=C+AB\)&lt;/span&gt;)
&lt;ul&gt;
&lt;li&gt;Cannon’s algorithm: systolic + block matmul,&lt;/li&gt;
&lt;li&gt;SUMMA: broadcast and outer product.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Local matmul can be done in blocks to increase computational intensity.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;lu-factorization&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;LU factorization&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;lu-factorization-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;LU factorization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We would like to solve a system of linear equations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ax = b\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compute &lt;span class=&quot;math inline&quot;&gt;\(A=LU\)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; is lower and &lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt; is upper triangular&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;For any RHS &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;, do one forward- and one back-substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Ly = b,\quad Ux = y\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Complexity of forward/back substitution: &lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;gaussian-elimination-is-lu&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gaussian elimination is LU&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The result of Gaussian elimination is an upper triangular matrix &lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At step &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;, below diagonal entries in column &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; are zeroed out&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} l_{ik} &amp;amp;= \frac{a_{ik}}{a_{kk}},\\a_{i*} &amp;amp;\leftarrow a_{i*} - l_{ik} a_{k*} \quad (i&amp;gt;k).\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(a_{i*}\)&lt;/span&gt; denotes &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;th row of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;gaussian-elimination-is-lu-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gaussian elimination is LU&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;As matrix operations&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
A^{(0)} &amp;amp;= A,\\
A^{(k)} &amp;amp;= L_k A^{(k-1)} = (I - {l_ke_k^T})A^{(k-1)}, \quad (k=1,\dots,n)\\
l_k &amp;amp;= (0,\dots,0,l_{k+1,k}, \dots, l_{n,k}),\\
U &amp;amp;= A^{(n)}.
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar smaller&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[A^{(1)} \leftarrow \begin{bmatrix} 1 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ -l_{21} &amp;amp; 1 &amp;amp; &amp;amp; &amp;amp; \\  -l_{31} &amp;amp; 0 &amp;amp;1 &amp;amp; &amp;amp; \\  \vdots &amp;amp; &amp;amp; &amp;amp; \ddots&amp;amp; &amp;amp; \\  -l_{n1}&amp;amp; 0 &amp;amp; 0 &amp;amp; \dots &amp;amp; 1 &amp;amp;\end{bmatrix} A\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Observations
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(L_k^{-1} = I + l_k e_k^T\)&lt;/span&gt; (because &lt;span class=&quot;math inline&quot;&gt;\(l_{k,k}=0\)&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(L_1^{-1} L_2^{-1} \dots L_n^{-1} = I + \sum_k l_k e_k^T = L\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar smaller fragment&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L = \begin{bmatrix} 1 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ l_{21} &amp;amp; 1 &amp;amp; &amp;amp; &amp;amp; \\  l_{31} &amp;amp; l_{32} &amp;amp;1 &amp;amp; &amp;amp; \\  \vdots &amp;amp; &amp;amp; &amp;amp; \ddots&amp;amp; &amp;amp; \\  l_{n1}&amp;amp; l_{n2} &amp;amp; l_{n3} &amp;amp; \dots &amp;amp; 1 &amp;amp;\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;in-place-lu&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;In-place LU&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource python numberLines&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;):                &lt;span class=&quot;co&quot;&gt;# columns&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(k&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n):            &lt;span class=&quot;co&quot;&gt;# each row&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;        L[i,k] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A[i,k]&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;A[k,k]        &lt;span class=&quot;co&quot;&gt;# row multipliers, in-place: A[i,k] /= A[k,k]&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-5&quot; data-line-number=&quot;5&quot;&gt;        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(k&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n):        &lt;span class=&quot;co&quot;&gt;# each element&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-6&quot; data-line-number=&quot;6&quot;&gt;            A[i,j] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A[i,j] &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; L[i,k] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; A[k,j]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Upon termination
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; is in the lower part of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; (store &lt;code&gt;L[i,k]&lt;/code&gt; in &lt;code&gt;A[i,k]&lt;/code&gt; for in-place factorization)&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt; is in the upper part&lt;/li&gt;
&lt;li&gt;Not storing ones on the diagonal for &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Serial time &lt;span class=&quot;math inline&quot;&gt;\(T_s = t_c \frac{n^3}{3}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In practice rows are interchanged (i.e., pivoting) to ensure existence and stability&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ PA = LU\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; is a permutation matrix (exchanges rows of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;lu-using-blas&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;LU using BLAS&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode numberSource python numberLines&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;):               &lt;span class=&quot;co&quot;&gt;# columns&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;    I &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(k&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;    A[I,k] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A[I,k]&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;A[k,k]           &lt;span class=&quot;co&quot;&gt;# BLAS 1: scale a vector&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-5&quot; data-line-number=&quot;5&quot;&gt;    A[I,I] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A[I,I] &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; A[I,k]&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;A[k,I]  &lt;span class=&quot;co&quot;&gt;# BLAS 2: outer product, rank 1 update&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Computational intensity of BLAS 1 and 2 routines are low&lt;/li&gt;
&lt;li&gt;Can we express the factorization as BLAS 3?&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;recursive-lu&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Recursive LU&lt;/h2&gt;
&lt;p&gt;Express &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; as blocks and recursively factorize sub-blocks&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
\begin{bmatrix} A_{11} &amp;amp; A_{12} \\ A_{21} &amp;amp; A_{22} \end{bmatrix} =
\begin{bmatrix} L_{11} &amp;amp; 0      \\ L_{21} &amp;amp; L_{22} \end{bmatrix}
\begin{bmatrix} U_{11} &amp;amp; U_{12} \\ 0      &amp;amp; U_{22} \end{bmatrix},
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} A_{11} &amp;amp;= L_{11} U_{11}, &amp;amp;A_{12} &amp;amp;= L_{11} U_{12},\\
A_{21} &amp;amp;= L_{21} U_{11}, &amp;amp;A_{22} &amp;amp;= L_{21} U_{12} + L_{22} U_{22}.
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Factorize &lt;span class=&quot;math inline&quot;&gt;\(A_{11}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Compute &lt;span class=&quot;math inline&quot;&gt;\(U_{12} = L_{11}^{-1}A_{12} \quad\text{and}\quad L_{21} = A_{21}U_{11}^{-1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Factorize &lt;span class=&quot;math inline&quot;&gt;\(A_{22}-L_{21}U_{12}\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Parallel, if you have parallel BLAS&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;lu-using-blas-3-iterative&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;LU using BLAS 3 (iterative)&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;Delay propagating updates to all of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Similar steps to recursive but different block sizes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Combine &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; rank-1 updates and do a single rank-&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; update (matmul)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; should be small so that active row/columns fit in cache&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; should be large enough so that matmul is faster than matvec&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-lu-block.png&quot; class=&quot;center plain&quot; width=&quot;350&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;lu-task-partitioning&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;LU task partitioning&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For each &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; there is &lt;span class=&quot;math inline&quot;&gt;\((n-k)^2\)&lt;/span&gt; fine-grained tasks&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Layout (on the matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;)
&lt;ul&gt;
&lt;li&gt;1D row/columns
&lt;ul&gt;
&lt;li&gt;Bad load balance, idle processors&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1D row/column cyclic
&lt;ul&gt;
&lt;li&gt;Lose locality, difficult communication&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2D block
&lt;ul&gt;
&lt;li&gt;Bad load balance&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2D block cyclic&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-cyclic-block.png&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;d-row-partition&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;1D row partition&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Divide rows evenly
&lt;ul&gt;
&lt;li&gt;The processor holding row &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; scales the row&lt;/li&gt;
&lt;li&gt;One-to-all Broadcast row &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;All processors perform rank-1 update&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{one step} \approx t_c \frac{n}{p}(n-k) + (t_s + t_w (n-k) ) \log p\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[ T_p = t_c \frac{n^3}{p} + (t_s n + t_w n^2) \log p\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[ E^{-1} = O\left(1+\frac{p\log p}{n}\right)\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Improvement idea?&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;d-row-partition-pipelined&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;1D row partition (pipelined)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sequentially send rows to the next processor
&lt;ul&gt;
&lt;li&gt;Start “wave” &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; from processor &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; at time &lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt; (different for processor 0)&lt;/li&gt;
&lt;li&gt;Last processor finished at time &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ T_p = t_c \frac{n^3}{p} + (t_s n + t_w n^2)\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bad load balancing: &lt;span class=&quot;math inline&quot;&gt;\(P_1 \&amp;amp; P_p\)&lt;/span&gt; are idle for &lt;span class=&quot;math inline&quot;&gt;\(O(p)\)&lt;/span&gt; time&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;d-block&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;2D block&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Steps are similar to delayed block factorization
&lt;ul&gt;
&lt;li&gt;Factorize diagonal block&lt;/li&gt;
&lt;li&gt;One-to-all broadcast lower block along processor row&lt;/li&gt;
&lt;li&gt;Broadcast &lt;span class=&quot;math inline&quot;&gt;\(\tilde U\)&lt;/span&gt; down&lt;/li&gt;
&lt;li&gt;Broadcast &lt;span class=&quot;math inline&quot;&gt;\(\tilde L\)&lt;/span&gt; across&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use 2D block cyclic layout for better load balancing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Blocking broadcast&lt;/em&gt;&lt;/strong&gt; is not cost-optimal
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pipeline:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{step}~k  = t_c \frac{(n-k)^2}{p} + 2\left(t_s + t_w \frac{n-k}{\sqrt{p}}\right), \quad T_p = t_c \frac{n^3}{3p} + 2 t_s n + t_w \frac{n^2}{\sqrt{p}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We ignore the cost of one-to-all broadcast of the lower block.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;lu-with-partial-pivoting&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;LU with partial pivoting&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Find the maximum entry in column &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; below the diagonal, use that row for zeroing out
&lt;ul&gt;
&lt;li&gt;Necessary for numerical stability&lt;/li&gt;
&lt;li&gt;Required if the diagonal element becomes zero&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Breaks the pipelining algorithm&lt;/em&gt;&lt;/strong&gt; (why?)&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;Previous step should terminate before finding the maximum&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Requires a reduction along column &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; to find maximum&lt;/li&gt;
&lt;li&gt;Exchange rows
&lt;ul&gt;
&lt;li&gt;explicitly (communication)&lt;/li&gt;
&lt;li&gt;implicitly (may affect load balancing)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;block-lu-with-pp-as-in-scalapack&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Block LU with PP (as in ScaLAPACK)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;For each &lt;span class=&quot;math inline&quot;&gt;\(b \times b\)&lt;/span&gt; block of &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Compute &lt;span class=&quot;math inline&quot;&gt;\(LU\)&lt;/span&gt; with PP in columns (swap sub-rows)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Broadcast pivot information (swap complete rows)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Broadcast &lt;span class=&quot;math inline&quot;&gt;\(L_{11}\)&lt;/span&gt; and compute &lt;span class=&quot;math inline&quot;&gt;\(U_{12}\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update trailing matrix with a rank-&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; update&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;block-lu-with-pp-steps&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Block LU with PP steps&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-pivot.png&quot; alt=&quot;Find pivot&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Find pivot&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-exchange.png&quot; alt=&quot;Exchange rows&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Exchange rows&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;block-lu-with-pp-steps-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Block LU with PP steps&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-block.png&quot; alt=&quot;Update block&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Update block&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-bcast-row.png&quot; alt=&quot;Broadcast all row swaps&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Broadcast all row swaps&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;block-lu-with-pp-steps-2&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Block LU with PP steps&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-exchange-all.png&quot; alt=&quot;Apply row exchanges&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Apply row exchanges&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-l11-bcast.png&quot; alt=&quot;Broadcast L11&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Broadcast L11&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;block-lu-with-pp-steps-3&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Block LU with PP steps&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-precross.png&quot; alt=&quot;Broadcast A blocks&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Broadcast &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; blocks&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar fragment&quot;&gt;
&lt;figure&gt;
&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-gepp-block-update.png&quot; alt=&quot;Update trailing matrix&quot; class=&quot;center plain&quot; width=&quot;400&quot; /&gt;&lt;figcaption&gt;Update trailing matrix&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;section id=&quot;faster-parallel-pivoting&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Faster parallel pivoting&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Communication Avoiding
&lt;ul&gt;
&lt;li&gt;Tournament pivoting
&lt;ul&gt;
&lt;li&gt;Compute LU for the local in the process column&lt;/li&gt;
&lt;li&gt;Pick top &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; rows from each local LU, recurse&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Communication avoiding Gaussian elimination, Grigori, Demmel, Xiang, SC ’08&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;cholesky-factorization&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;Cholesky factorization&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;cholesky-factorization-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Cholesky factorization&lt;/h2&gt;
&lt;p&gt;Any symmetric positive definite matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; has a &lt;em&gt;Cholesky Factorization&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = LL^T,\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; is lower triangular.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cholesky factorization is faster than &lt;span class=&quot;math inline&quot;&gt;\(LU\)&lt;/span&gt; (less FLOPs and no pivoting).&lt;/li&gt;
&lt;li&gt;Incomplete Cholesky for &lt;em&gt;sparse matrices&lt;/em&gt; can be used as &lt;em&gt;preconditioner&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;cholesky-algorithm&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Cholesky algorithm&lt;/h2&gt;
&lt;p&gt;Consider the following blocking of matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
\begin{bmatrix} a &amp;amp; b^T   \\b &amp;amp; C\end{bmatrix} =
\begin{bmatrix} l &amp;amp; 0     \\r &amp;amp; L\end{bmatrix}
\begin{bmatrix} l &amp;amp; r^T   \\0 &amp;amp; L^T\end{bmatrix}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; are scalars, &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; are vectors, &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; are matrices. Then&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
a &amp;amp;= l^2,&amp;amp;
b &amp;amp;= l r,&amp;amp;
C &amp;amp;= rr^T + L L^T.
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode numberSource python numberLines&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;    a[k,k] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sqrt(a[k,k])     &lt;span class=&quot;co&quot;&gt;# in-place&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;    I &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(k&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,n)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;    a[I,k] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a[I,k]&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;a[k,k]    &lt;span class=&quot;co&quot;&gt;# computing r vector&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-6&quot; data-line-number=&quot;6&quot;&gt;    &lt;span class=&quot;co&quot;&gt;# rank-1 update with r r^T. A &amp;amp; C are symmetric, only need to update below diagonal.&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-7&quot; data-line-number=&quot;7&quot;&gt;    a[I,I] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a[I,I] &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; outer(a[I,k],a[I,k])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;It does not require pivoting&lt;/em&gt;&lt;/strong&gt; for stability. Guaranteed to have non-zero diagonal because &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; is SPD.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;parallelization&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Parallelization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LU algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;loop-ordering-for-cholesky&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Loop ordering for Cholesky&lt;/h2&gt;
&lt;div class=&quot;slide-pillars&quot;&gt;
&lt;div class=&quot;slide-pillar&quot; style=&quot;flex:2.5;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;It is clear that &lt;span class=&quot;math inline&quot;&gt;\(i,j\)&lt;/span&gt; loops can be easily exchanged. What happens when about &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; is first?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
\begin{bmatrix} LL^T &amp;amp; b   \\b^T &amp;amp; c \end{bmatrix} =
\begin{bmatrix} L &amp;amp; 0     \\ r^T&amp;amp; m \end{bmatrix}
\begin{bmatrix} L^T &amp;amp; r   \\0 &amp;amp; m\end{bmatrix}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;Implications:
&lt;ul&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(kji\)&lt;/span&gt;: rank-1 update to the trailing matrix&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(jki\)&lt;/span&gt;: update current column by matvec&lt;/li&gt;
&lt;li class=&quot;fragment&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(ikj\)&lt;/span&gt;: update current row by back-substitution&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;slide-pillar&quot;&gt;
&lt;p&gt;&lt;img data-src=&quot;assets/dedicated-hpc18/img/06-chol-order.png&quot; class=&quot;center&quot; width=&quot;250&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;&lt;/section&gt;
&lt;section&gt;&lt;section id=&quot;qr-factorization&quot; class=&quot;title-slide slide level1&quot;&gt;&lt;h1&gt;QR factorization&lt;/h1&gt;&lt;/section&gt;&lt;section id=&quot;qr-factorization-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;QR factorization&lt;/h2&gt;
&lt;p&gt;For any &lt;span class=&quot;math inline&quot;&gt;\(m\times n\)&lt;/span&gt; matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; (&lt;span class=&quot;math inline&quot;&gt;\(m\ge n\)&lt;/span&gt;) there exist orthogonal matrix &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; and upper triangular matrix &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; such that&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = QR \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To solve linear systems we can solve the triangular system&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ R x = Q^T b \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;qr-algorithms&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;QR algorithms&lt;/h2&gt;
&lt;p&gt;QR can be computed iteratively by zeroing out below diagonal elements in &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; using orthogonal vectors&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gram-Schmidt orthogonalization
&lt;ul&gt;
&lt;li&gt;Usually poor orthogonality&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Householder transformations (reflections)
&lt;ul&gt;
&lt;li&gt;Good orthogonality&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Givens transformations (rotations)
&lt;ul&gt;
&lt;li&gt;More expensive than Householder version, easier to parallelize&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;householder-transformation&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Householder transformation&lt;/h2&gt;
&lt;p&gt;Consider the operator&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ H = I - 2 v v^T \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;for some &lt;em&gt;unit&lt;/em&gt; vector &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;, to be determined.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By construction &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; is symmetric and orthogonal, i.e., &lt;span class=&quot;math inline&quot;&gt;\(HH^T = I\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Suppose we have a vector &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; whose elements we want to zero out&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ H x = a \begin{bmatrix} 1\\0\\\vdots\\0\end{bmatrix} = a e_1.\]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;householder-transformation-1&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Householder transformation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Since &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; is orthogonal, &lt;span class=&quot;math inline&quot;&gt;\(\|H x \| = \|x \| = |a|\)&lt;/span&gt; or&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ a = \pm \|x\|\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiplying &lt;span class=&quot;math inline&quot;&gt;\(Hx\)&lt;/span&gt; we have&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ 2(v^T x) v = x - a e_1 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;implying that &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; is a scalar multiple of &lt;span class=&quot;math inline&quot;&gt;\(x - a e_1\)&lt;/span&gt;. Since it is a unit vector we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ v = \frac{x - a e_1}{\| x - a e_1 \|} \]&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section id=&quot;householder-qr&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Householder QR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Similar to LU, below diagonal elements are set to zero
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; is stored in a factored form in the lower part&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel implementation is very similar to LU&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;&lt;section id=&quot;gram-schmidt-qr&quot; class=&quot;slide level2&quot;&gt;
&lt;h2&gt;Gram-Schmidt QR&lt;/h2&gt;
&lt;p&gt;For matrix &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;, iteratively define&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
u_i &amp;amp;= a_i - \sum_{j=1}^{k-1} (a_i\cdot q_j)q_j \\
q_i &amp;amp;= u_i/\|u_i\|
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In matrix form&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned}
\begin{bmatrix} a_1 &amp;amp; a_2 &amp;amp; \dots &amp;amp; a_n \end{bmatrix} =
\begin{bmatrix} q_1 &amp;amp; q_2 &amp;amp; \dots &amp;amp; q_n \end{bmatrix}
\begin{bmatrix}
a_1\cdot q_1 &amp;amp; a_2\cdot q_1 &amp;amp; \dots &amp;amp; a_n\cdot q_1\\
     0       &amp;amp; a_2\cdot q_2 &amp;amp; \dots &amp;amp; a_n\cdot q_2\\
     0       &amp;amp; 0            &amp;amp; \ddots &amp;amp;  \dots    \\
     0       &amp;amp; 0            &amp;amp;  0      &amp;amp;  a_n\cdot q_n  \\
\end{bmatrix}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Partitioning?&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script src=&quot;assets/js/reveal.js/lib/js/head.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;assets/js/reveal.js/js/reveal.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Display the page number of the current slide
        slideNumber: 'c',
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Enables touch navigation on devices with touch input
        touch: true,
        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom
        // The &quot;normal&quot; size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 720,


      // Optional reveal.js plugins
      dependencies: [
          { src: 'assets/js/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'assets/js/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'assets/js/reveal.js/plugin/notes/notes.js', async: true }
      ]
      });
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</description>
      <pubDate>Thu, 04 Oct 2018 00:00:00 -0600</pubDate>
      <link>/~rahimian/articles/18/hpc18-07-densela.sl.html</link>
      <guid isPermaLink="true">/~rahimian/articles/18/hpc18-07-densela.sl.html</guid>
      
      
      <category>lecture</category>
      
    </item>
    
  </channel>
</rss>
